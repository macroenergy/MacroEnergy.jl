var documenterSearchIndex = {"docs":
[{"location":"references/#Package-Reference","page":"References","title":"Package Reference","text":"","category":"section"},{"location":"references/#MacroEnergy.add_default_system_data!-Tuple{AbstractDict{Symbol, Any}}","page":"References","title":"MacroEnergy.add_default_system_data!","text":"add_default_system_data!(system_data::AbstractDict{Symbol,Any})::Nothing\n\nAdd the default system data to the system data dictionary. This adds any required fields that are missing.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.clean_up_keys-Tuple{AbstractDict{Symbol, Any}}","page":"References","title":"MacroEnergy.clean_up_keys","text":"clean_up_keys(dict::AbstractDict{Symbol,Any})::AbstractDict{Symbol,Any}\n\nClean up a Dict{Symbol,Any} object by copying values from keys that match the key name.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.collect_results","page":"References","title":"MacroEnergy.collect_results","text":"collect_results(system::System, model::Model, scaling::Float64=1.0)\n\nReturns a DataFrame with all the results after the optimization is performed. \n\nArguments\n\nsystem::System: The system object containing the case inputs.\nmodel::Model: The model being optimized.\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A `DataFrame containing all the outputs from a system.\n\nExample\n\ncollect_results(system, model)\n198534×12 DataFrame\n    Row │ case_name  commodity    commodity_subtype  zone        resource_id                component_id                       type              variable  segment  time   value\n        │ Missing    Symbol       Symbol             Symbol      Symbol                     Symbol                             Symbol            Symbol    Int64    Int64  Float64\n────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n      1 │   missing  Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      1  0.0\n      2 │   missing  Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      2  0.0\n      3 │   missing  Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      3  0.0\n      ...\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.create_output_path","page":"References","title":"MacroEnergy.create_output_path","text":"create_output_path(system::System, path::String=system.data_dirpath)\n\nCreate and return the path to the output directory for storing results based on system settings.\n\nArguments\n\nsystem::System: The system object containing settings and configuration\npath::String: Base path for the output directory (defaults to system.data_dirpath)\n\nReturns\n\nString: Path to the created output directory\n\nThe function creates an output directory based on system settings. If OverwriteResults  is false, it will avoid overwriting existing directories by appending incremental numbers  (e.g., \"001\", \"002\") to the directory name. The directory is created if it doesn't exist.\n\nExample\n\njulia> system.settings\n(..., OverwriteResults = true, OutputDir = \"result_dir\")\njulia> output_path = create_output_path(system)\n# Returns \"path/to/system.data_dirpath/result_dir\" or \"path/to/system.data_dirpath/result_dir_001\" if original exists\njulia> output_path = create_output_path(system, \"path/to/output\")\n# Returns \"path/to/output/result_dir\" or \"path/to/output/result_dir_001\" if original exists\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.eager_load_json_inputs-Tuple{AbstractDict{Symbol, Any}, AbstractString}","page":"References","title":"MacroEnergy.eager_load_json_inputs","text":"eager_load_json_inputs(json_data::AbstractDict{Symbol, Any}, rel_path::AbstractString)::AbstractDict{Symbol, Any}\n\nRecursively loads data from sources specified in an input Dict{Symbol,Any} and returns a new \nDict{Symbol,Any} object with the data inserted.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.eager_load_json_inputs-Tuple{AbstractVector{<:AbstractDict{Symbol, Any}}, AbstractString}","page":"References","title":"MacroEnergy.eager_load_json_inputs","text":"eager_load_json_inputs(json_data::AbstractVector{<:AbstractDict{Symbol,Any}}, rel_path::AbstractString)::AbstractVector{<:AbstractDict{Symbol,Any}}\n\nRecursively loads data from sources specified in several input Dict{Symbol,Any}, stored as a Vector, \nand returns a new Vector{Dict{Symbol,Any}} object with the data inserted.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.fetch_data","page":"References","title":"MacroEnergy.fetch_data","text":"fetch_data(path::AbstractString, dict::AbstractDict{Symbol, Any}, root_path::AbstractString, lazy_load::Bool = true)::Any\n\nFetch data from a JSON file or directory and return it as a Dict{Symbol,Any} object.\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.filter_edges_by_asset_type!-Tuple{Vector{MacroEnergy.AbstractEdge}, Union{Symbol, Vector{Symbol}}, Dict{Symbol, Base.RefValue{<:AbstractAsset}}}","page":"References","title":"MacroEnergy.filter_edges_by_asset_type!","text":"filter_edges_by_asset_type!(edges::Vector{AbstractEdge}, asset_type::Union{Symbol,Vector{Symbol}}, edge_asset_map::Dict{Symbol,Base.RefValue{<:AbstractAsset}})\n\nFilter edges and their associated assets by asset type.\n\nArguments\n\nedges::Vector{AbstractEdge}: Edges to filter\nasset_type::Union{Symbol,Vector{Symbol}}: Target asset type(s)\nedge_asset_map::Dict{Symbol,Base.RefValue{<:AbstractAsset}}: Mapping of edges to assets\n\nEffects\n\nModifies edges in-place to keep only edges matching the asset type\nModifies edge_asset_map to keep only matching assets\n\nThrows\n\nArgumentError: If none of the requested asset types are found in the system\n\nExample\n\nfilter_edges_by_asset_type!(edges, :Battery, edge_asset_map)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.filter_edges_by_commodity!","page":"References","title":"MacroEnergy.filter_edges_by_commodity!","text":"filter_edges_by_commodity!(edges::Vector{AbstractEdge}, commodity::Union{Symbol,Vector{Symbol}}, edge_asset_map::Dict{Symbol,Base.RefValue{<:AbstractAsset}}=Dict{Symbol,Base.RefValue{<:AbstractAsset}}())\n\nFilter the edges by commodity and update the edgeassetmap to match the filtered edges (optional).\n\nArguments\n\nedges::Vector{AbstractEdge}: The edges to filter\ncommodity::Union{Symbol,Vector{Symbol}}: The commodity to filter by\nedge_asset_map::Dict{Symbol,Base.RefValue{<:AbstractAsset}}: The edgeassetmap to update (optional)\n\nEffects\n\nModifies edges in-place to keep only edges matching the commodity type\nIf edge_asset_map is provided, filters it to match remaining edges\n\nExample\n\nfilter_edges_by_commodity!(edges, :Electricity)\nfilter_edges_by_commodity!(edges, [:Electricity, :NaturalGas], edge_asset_map)\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.find_available_path","page":"References","title":"MacroEnergy.find_available_path","text":"find_available_path(path::String, basename::String=\"results\"; max_attempts::Int=999)\n\nChoose an available output directory with the name \"basename_<number>\" by appending incremental numbers to the base path.\n\nArguments\n\npath::String: Base path for the output directory.\nbasename::String: Base name of the output directory.\nmax_attempts::Int: Maximum number of attempts to find an available directory (default is 999).\n\nReturns\n\nString: Full path to the chosen output directory.\n\nThe function first expands the given path to its full path and then attempts to find an available directory by appending incremental numbers (e.g., \"basename001\", \"basename002\") up to max_attempts times. If an available directory is found, it returns the full path to that directory. If no available directory is found after max_attempts attempts, it raises an error.\n\nExample\n\njulia> path = \"path/to/output\"\njulia> output_path = find_available_path(path)\n# Returns \"path/to/output/results_001\" or \"path/to/output/results_002\" etc.\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.get_optimal_capacity-Tuple{MacroEnergy.System}","page":"References","title":"MacroEnergy.get_optimal_capacity","text":"get_optimal_capacity(system::System; scaling::Float64=1.0)\n\nGet the optimal capacity values for all assets/edges in a system.\n\nArguments\n\nsystem::System: The system containing the assets/edges to analyze\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A dataframe containing the optimal capacity values for all assets/edges, with missing columns removed\n\nExample\n\nget_optimal_capacity(system)\n153×8 DataFrame\n Row │ commodity    commodity_subtype  zone           resource_id                        component_id                       type              variable  value    \n     │ Symbol       Symbol             Symbol         Symbol                             Symbol                             Symbol            Symbol    Float64 \n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Electricity  capacity           elec_SE        existing_solar_SE                  existing_solar_SE_edge             VRE               capacity   8.5022\n   2 │ Electricity  capacity           elec_NE        existing_solar_NE                  existing_solar_NE_edge             VRE               capacity   0.0   \n   3 │ Electricity  capacity           elec_NE        existing_wind_NE                   existing_wind_NE_edge              VRE               capacity   3.6545\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_costs-Tuple{JuMP.Model}","page":"References","title":"MacroEnergy.get_optimal_costs","text":"get_optimal_costs(model::Model)\n\nGet the total, fixed, and variable costs for the system.\n\nArguments\n\nmodel::Model: The optimal model after the optimization\n\nReturns\n\nDataFrame: A dataframe containing the total, fixed, and variable costs for the system, with missing columns removed\n\nExample\n\nget_optimal_costs(model)\n3×8 DataFrame\n Row │ commodity  commodity_subtype  zone    resource_id  component_id  type    variable      value   \n     │ Symbol     Symbol             Symbol  Symbol       Symbol        Symbol  Symbol        Float64 \n─────┼───────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ all        cost               all     all          all           Cost    FixedCost     22471.1\n   2 │ all        cost               all     all          all           Cost    VariableCost  14316.2\n   3 │ all        cost               all     all          all           Cost    TotalCost     36787.3\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_flow-Tuple{AbstractAsset}","page":"References","title":"MacroEnergy.get_optimal_flow","text":"get_optimal_flow(asset::AbstractAsset, scaling::Float64=1.0)\n\nGet the optimal flow values for all edges in an asset.\n\nArguments\n\nasset::AbstractAsset: The asset containing the edges to analyze\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A dataframe containing the optimal flow values for all edges, with missing columns removed\n\nExample\n\nasset = get_asset_by_id(system, :elec_SE)\nget_optimal_flow(asset)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_flow-Tuple{MacroEnergy.AbstractEdge}","page":"References","title":"MacroEnergy.get_optimal_flow","text":"get_optimal_flow(edge::AbstractEdge, scaling::Float64=1.0)\n\nGet the optimal flow values for an edge.\n\nArguments\n\nedge::AbstractEdge: The edge to analyze\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A dataframe containing the optimal flow values for the edge, with missing columns removed\n\nExample\n\nasset = get_asset_by_id(system, :elec_SE)\nelec_edge = asset.elec_edge\nget_optimal_flow(elec_edge)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_flow-Tuple{MacroEnergy.System}","page":"References","title":"MacroEnergy.get_optimal_flow","text":"get_optimal_flow(\n    system::System; \n    scaling::Float64=1.0, \n    commodity::Union{AbstractString,Vector{<:AbstractString},Nothing}=nothing, \n    asset_type::Union{AbstractString,Vector{<:AbstractString},Nothing}=nothing\n)\n\nGet the optimal flow values for all edges in a system.\n\nFiltering\n\nResults can be filtered by:\n\ncommodity: Specific commodity type(s)\nasset_type: Specific asset type(s)\n\nPattern Matching\n\nTwo types of pattern matching are supported:\n\nParameter-free matching:\n\"ThermalPower\" matches any ThermalPower{...} type (i.e. no need to specify parameters inside {})\nWildcards using \"*\":\n\"ThermalPower*\" matches ThermalPower{Fuel}, ThermalPowerCCS{Fuel}, etc.\n\"CO2*\" matches CO2, CO2Captured, etc.\n\nArguments\n\nsystem::System: The system containing the all edges to output   \nscaling::Float64: The scaling factor for the results.\ncommodity::Union{AbstractString,Vector{<:AbstractString},Nothing}: The commodity to filter by\nasset_type::Union{AbstractString,Vector{<:AbstractString},Nothing}: The asset type to filter by\n\nReturns\n\nDataFrame: A dataframe containing the optimal flow values for all edges, with missing columns removed\n\nExample\n\nget_optimal_flow(system)\n186984×11 DataFrame\n    Row │ commodity    commodity_subtype  zone        resource_id                component_id                       type              variable  segment  time   value     \n        │ Symbol       Symbol             Symbol      Symbol                     Symbol                             Symbol            Symbol    Int64    Int64  Float64\n────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n      1 │ Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      1  0.0    \n      2 │ Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      2  0.0    \n      3 │ Biomass      flow               bioherb_SE  SE_BECCS_Electricity_Herb  SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  flow            1      3  0.0    \n      ...\n# Filter by commodity\nget_optimal_flow(system, commodity=\"Electricity\")\n# Filter by commodity and asset type using parameter-free matching\nget_optimal_flow(system, commodity=\"Electricity\", asset_type=\"ThermalPower\") # only ThermalPower{Fuel} will be returned\n# Filter by commodity and asset type using wildcard matching\nget_optimal_flow(system, commodity=\"Electricity\", asset_type=\"ThermalPower*\") # all types starting with ThermalPower (e.g., ThermalPower{Fuel}, ThermalPowerCCS{Fuel}) will be returned)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_new_capacity-Tuple{MacroEnergy.System}","page":"References","title":"MacroEnergy.get_optimal_new_capacity","text":"get_optimal_new_capacity(system::System; scaling::Float64=1.0)\n\nGet the optimal new capacity values for all assets/edges in a system.\n\nArguments\n\nsystem::System: The system containing the assets/edges to analyze\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A dataframe containing the optimal new capacity values for all assets/edges, with missing columns removed\n\nExample\n\nget_optimal_new_capacity(system)\n153×8 DataFrame\n Row │ commodity    commodity_subtype  zone           resource_id                        component_id                       type              variable      value  \n     │ Symbol       Symbol             Symbol         Symbol                             Symbol                             Symbol            Symbol        Float64\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Biomass      capacity           bioherb_SE     SE_BECCS_Electricity_Herb          SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  new_capacity      0.0\n   2 │ Biomass      capacity           bioherb_MIDAT  MIDAT_BECCS_Electricity_Herb       MIDAT_BECCS_Electricity_Herb_bio…  BECCSElectricity  new_capacity      0.0\n   3 │ Biomass      capacity           bioherb_NE     NE_BECCS_Electricity_Herb          NE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  new_capacity      0.0\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_optimal_retired_capacity-Tuple{MacroEnergy.System}","page":"References","title":"MacroEnergy.get_optimal_retired_capacity","text":"get_optimal_retired_capacity(system::System; scaling::Float64=1.0)\n\nGet the optimal retired capacity values for all assets/edges in a system.\n\nArguments\n\nsystem::System: The system containing the assets/edges to analyze\nscaling::Float64: The scaling factor for the results.\n\nReturns\n\nDataFrame: A dataframe containing the optimal retired capacity values for all assets/edges, with missing columns removed\n\nExample\n\nget_optimal_retired_capacity(system)\n153×8 DataFrame\n Row │ commodity    commodity_subtype  zone           resource_id                        component_id                       type              variable      value    \n     │ Symbol       Symbol             Symbol         Symbol                             Symbol                             Symbol            Symbol        Float64  \n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Biomass      capacity           bioherb_SE     SE_BECCS_Electricity_Herb          SE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  retired_capacity  0.0\n   2 │ Biomass      capacity           bioherb_MIDAT  MIDAT_BECCS_Electricity_Herb       MIDAT_BECCS_Electricity_Herb_bio…  BECCSElectricity  retired_capacity  0.0\n   3 │ Biomass      capacity           bioherb_NE     NE_BECCS_Electricity_Herb          NE_BECCS_Electricity_Herb_biomas…  BECCSElectricity  retired_capacity  0.0\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_output_layout","page":"References","title":"MacroEnergy.get_output_layout","text":"get_output_layout(system::System, variable::Union{Nothing,Symbol}=nothing)::String\n\nGet the output layout (\"wide\" or \"long\") for a specific variable from system settings.\n\nArguments\n\nsystem::System: System containing output layout settings\nvariable::Union{Nothing,Symbol}=nothing: Variable to get layout for (e.g., :Cost, :Flow)\n\nReturns\n\nString indicating layout format: \"wide\" or \"long\"\n\nSettings Format\n\nThe OutputLayout setting can be specified in three ways:\n\nGlobal string setting:\nsettings = (OutputLayout=\"wide\",)  # Same layout for all variables\nPer-variable settings using NamedTuple:\nsettings = (OutputLayout=(Cost=\"wide\", Flow=\"long\"),)\nDefault behavior:\nReturns \"long\" if setting is missing or invalid\nLogs warning for unsupported types or missing variables\n\nExamples\n\n# Global layout\nsystem = System(settings=(OutputLayout=\"wide\",))\nget_output_layout(system, :Cost)  # Returns \"wide\"\n\n# Per-variable layout\nsystem = System(settings=(OutputLayout=(Cost=\"wide\", Flow=\"long\"),))\nget_output_layout(system, :Cost)  # Returns \"wide\"\nget_output_layout(system, :Flow)  # Returns \"long\"\nget_output_layout(system, :Other) # Returns \"long\" with warning\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.get_value-Tuple{AbstractDict, Vector{Symbol}}","page":"References","title":"MacroEnergy.get_value","text":"get_value(dict::AbstractDict, keys::Vector{Symbol})\n\nGet the value from a dictionary based on a sequence of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary from which to retrieve the value.\nkeys::Vector{Symbol}: The sequence of keys to traverse the dictionary.\n\nReturns\n\nThe value retrieved from the dictionary based on the given keys.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value(dict, [:a, :b]) # returns 1\nget_value(dict, [:a, :c, :b]) # returns 2\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.get_value_and_keys","page":"References","title":"MacroEnergy.get_value_and_keys","text":"get_value_and_keys(dict::AbstractDict, target_key::Symbol, keys=Symbol[])\n\nRecursively searches for a target key in a dictionary and returns a list of  tuples containing the value associated with the target key and the keys leading  to it. This function is used to replace the path to a timeseries file with the actual vector of data.\n\nArguments\n\ndict::AbstractDict: The (nested) dictionary to search in.\ntarget_key::Symbol: The key to search for.\nkeys=Symbol[]: (optional) The keys leading to the current dictionary.\n\nReturns\n\nvalue_keys: A list of tuples, where each tuple contains                - the value associated with the target key               - the keys leading to it in the nested dictionary.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value_and_keys(dict, :b) # returns [(1, [:a, :b]), (2, [:a, :c, :b])]\n\nWhere the first element of the tuple is the value of the key :b and the second  element is the list of keys to reach that value.\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.json_to_csv","page":"References","title":"MacroEnergy.json_to_csv","text":"json_to_csv(json_data::AbstractDict{Symbol, Any}, vec_data::VectorData=VectorData(), nesting_str::AbstractString=\"--\")\n\nConvert a JSON object to a CSV file. The Dict should contain a single \nasset described by :type, :instance_data, and possibly :global_data fields.\n\n# Arguments\n- `json_data`: The JSON object to convert.\n- `vec_data`: The VectorData object to store the timeseries or other vector data in.\n- `nesting_str`: The string used to denote nested properties.\n\n# Returns\n- A vector of OrderedDicts containing the data for each instance\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.load_csv-Union{Tuple{AbstractString}, Tuple{S}} where S<:Union{Symbol, Vector{Symbol}}","page":"References","title":"MacroEnergy.load_csv","text":"load_time_series_data(file_path::AbstractString, header::AbstractVector{Symbol})::Dict{Symbol,Any}\n\nLoad time series data from one or more headers in a CSV file and return as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.load_default_system_data-Tuple{}","page":"References","title":"MacroEnergy.load_default_system_data","text":"load_default_system_data()::Dict{Symbol,Any}\n\nLoad the default system data from a JSON file.  This describes the default locations for the system data files.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.load_json_inputs-Tuple{AbstractString}","page":"References","title":"MacroEnergy.load_json_inputs","text":"load_json_inputs(file_path::AbstractString; rel_path::AbstractString=dirname(file_path), lazy_load::Bool = true)::Dict{Symbol,Any}\n\nLoad JSON data from a file and return a Dict{Symbol,Any} object. The data can all be included in the \nspecified JSON file or distributed across multiple files and directories, with each source specified\nusing \"path\" or \"timeseries\" keys.\\n \nThe `rel_path` argument is used to specify the path relative to which the file paths of this distributed\ndata should be resolved.\\n\nIf `lazy_load` is set to `true`, then only the top-level data in the specified JSON file will be loaded. \nIf `lazy_load` is set to `false`, then the distrinuted data will be loaded recursively into the \nappropriate data structures.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.load_system_data","page":"References","title":"MacroEnergy.load_system_data","text":"load_system_data(file_path::AbstractString, rel_path::AbstractString; lazy_load::Bool = true)::Dict{Symbol,Any}\n\nLoad the system data (currently only from a JSON file) given a file path and directory to search for the file in. All other file names defined in the system data file are assumed to be relative to rel_path.\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.load_system_data-Tuple{AbstractString, MacroEnergy.System}","page":"References","title":"MacroEnergy.load_system_data","text":"load_system_data(system::System, file_path::AbstractString)::Dict{Symbol,Any}\n\nLoad the system data (currently only from a JSON file) given a file path and existing System. All other file names defined in the system data file are assumed to be relative to the data_dirpath field of the System.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{<:VRE}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{<:VRE}, data::AbstractDict{Symbol, Any}, system::System) -> VRE\n\nVRE is an alias for Union{SolarPV, WindTurbine}\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n- edges: Dict{Symbol, Any}\n    - edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{Battery}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{Battery}, data::AbstractDict{Symbol, Any}, system::System) -> Battery\n\nNecessary data fields:\n - storage: Dict{Symbol, Any}\n    - id: String\n    - commodity: String\n    - can_retire: Bool\n    - can_expand: Bool\n    - existing_capacity: Float64\n    - investment_cost: Float64\n    - fixed_om_cost: Float64\n    - loss_fraction: Float64\n    - min_duration: Float64\n    - max_duration: Float64\n    - min_storage_level: Float64\n    - min_capacity: Float64\n    - max_capacity: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n - edges: Dict{Symbol, Any}\n    - charge_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - efficiency: Float64\n    - discharge_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - efficiency\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{Electrolyzer}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{Electrolyzer}, data::AbstractDict{Symbol, Any}, system::System) -> Electrolyzer\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{FuelCell}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{FuelCell}, data::AbstractDict{Symbol, Any}, system::System) -> FuelCell\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - elec_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{HydroRes}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{HydroRes}, data::AbstractDict{Symbol, Any}, system::System) -> HydroRes\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{MustRun}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{MustRun}, data::AbstractDict{Symbol, Any}, system::System) -> MustRun\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{NaturalGasDAC}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{NaturalGasDAC}, data::AbstractDict{Symbol, Any}, system::System) -> NaturalGasDAC\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{ThermalHydrogenCCS}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{ThermalHydrogenCCS}, data::AbstractDict{Symbol, Any}, system::System) -> ThermalHydrogenCCS\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - elec_edge: Dict{Symbol,Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel_consumption: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - fuel_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_captured_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.make-Tuple{Type{ThermalHydrogen}, AbstractDict{Symbol, Any}, MacroEnergy.System}","page":"References","title":"MacroEnergy.make","text":"make(::Type{ThermalHydrogen}, data::AbstractDict{Symbol, Any}, system::System) -> ThermalHydrogen\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - elec_edge: Dict{Symbol,Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel_consumption: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - fuel_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.prep_system_data-Tuple{AbstractString}","page":"References","title":"MacroEnergy.prep_system_data","text":"prep_system_data(file_path::AbstractString)::Nothing\n\nThis attempts to load the system data from the file at file_path, adds any missing fields from the default system data, and writes the updated system data back to the file. In the future, we may change this to not write to the file, but for now, it's a quick way to ensure the system data is up-to-date.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.reshape_long-Tuple{DataFrames.DataFrame}","page":"References","title":"MacroEnergy.reshape_long","text":"reshape_long(df::DataFrame; id_cols::Vector{Symbol}=Symbol[], view::Bool=true)\n\nReshape a DataFrame from wide to long format.\n\nArguments\n\ndf::DataFrame: Input DataFrame\nid_cols::Vector{Symbol}: Columns to use as identifiers when stacking\nview::Bool: Whether to return a view of the DataFrame instead of a copy\n\nExamples\n\ndf_wide = DataFrame(id=[1,2], a=[10,20], b=[30,40])\ndf_long = reshape_long(df_wide, :time, :component_id, :value)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.reshape_wide","page":"References","title":"MacroEnergy.reshape_wide","text":"reshape_wide(df::DataFrame; variable_col::Symbol=:variable, value_col::Symbol=:value)\n\nReshape a DataFrame from long to wide format.\n\nArguments\n\ndf::DataFrame: Input DataFrame\nvariable_col::Symbol: Column name containing variable names\nvalue_col::Symbol: Column name containing values\n\nExamples\n\ndf_long = DataFrame(id=[1,1,2,2], variable=[:a,:b,:a,:b], value=[10,30,20,40])\ndf_wide = reshape_wide(df_long)\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.reshape_wide-Tuple{DataFrames.DataFrame, Union{Symbol, Vector{Symbol}}, Symbol, Symbol}","page":"References","title":"MacroEnergy.reshape_wide","text":"reshape_wide(df::DataFrame, id_cols::Union{Vector{Symbol},Symbol}, variable_col::Symbol, value_col::Symbol)\n\nReshape a DataFrame from long to wide format.\n\nArguments\n\ndf::DataFrame: DataFrame in long format to be reshaped\nid_cols::Union{Vector{Symbol},Symbol}: Column(s) to use as identifiers\nvariable_col::Symbol: Column containing variable names that will become new columns\nvalue_col::Symbol: Column containing values that will fill the new columns\n\nReturns\n\nDataFrame: Reshaped DataFrame in wide format\n\nThrows\n\nArgumentError: If required columns are not present in the DataFrame\n\nExamples\n\ndf_wide = reshape_wide(df, :year, :variable, :value)\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.search_assets-Tuple{Union{AbstractString, Vector{<:AbstractString}}, Vector{<:AbstractString}}","page":"References","title":"MacroEnergy.search_assets","text":"search_assets(asset_type, available_types)\n\nSearch for asset types in a list of available assets, supporting wildcards and parametric types.\n\nArguments\n\nasset_type::Union{AbstractString,Vector{<:AbstractString}}: Type(s) to search for\navailable_types::Vector{<:AbstractString}: Available asset types to search from\n\nReturns\n\nTuple of two vectors:\n\nVector{Symbol}: Found asset types\nVector{Symbol}: Missing asset types (only if no matches found)\n\nPattern Matching\n\nSupports three types of matches:\n\nExact match: \"Battery\" matches \"Battery\"\nParametric match: \"ThermalPower\" matches \"ThermalPower{Fuel}\"\nWildcard match: \"ThermalPower*\" matches both \"ThermalPower{Fuel}\" and \"ThermalPowerCCS{Fuel}\"\n\nExamples\n\n# Available assets\nassets = [\"Battery\", \"ThermalPower{Coal}\", \"ThermalPower{Gas}\"]\n\n# Exact match\nfound, missing = search_assets(\"Battery\", assets)\n# found = [:Battery], missing = []\n\n# Parametric match\nfound, missing = search_assets(\"ThermalPower\", assets)\n# found = [:ThermalPower{Coal}, :ThermalPower{Gas}], missing = []\n\n# Wildcard match\nfound, missing = search_assets(\"ThermalPower*\", assets)\n# found = [:ThermalPower{Coal}, :ThermalPower{Gas}], missing = []\n\n# Multiple types\nfound, missing = search_assets([\"Battery\", \"Solar\"], assets)\n# found = [:Battery], missing = [:Solar]\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.search_commodities-Tuple{Union{AbstractString, Vector{<:AbstractString}}, Vector{<:AbstractString}}","page":"References","title":"MacroEnergy.search_commodities","text":"search_commodities(commodities, available_commodities)\n\nSearch for commodity types in a list of available commodities, supporting wildcards and subtypes.\n\nArguments\n\ncommodities::Union{AbstractString,Vector{<:AbstractString}}: Commodity type(s) to search for\navailable_commodities::Vector{<:AbstractString}: Available commodity types to search from\n\nReturns\n\nTuple of two vectors:\n\nVector{Symbol}: Found commodity types\nVector{Symbol}: Missing commodity types (only if no matches found)\n\nPattern Matching\n\nSupports two types of matches:\n\nExact match: \"Electricity\" matches only \"Electricity\"\nWildcard match: \"CO2*\" matches both CO2 and its subtypes (e.g., CO2Captured)\n\nExamples\n\n# Available commodities\ncommodities = [\"Electricity\", \"CO2\", \"CO2Captured\"]\n\n# Exact match\nfound, missing = search_commodities(\"Electricity\", commodities)\n# found = [:Electricity], missing = []\n\n# Wildcard match\nfound, missing = search_commodities(\"CO2*\", commodities)\n# found = [:CO2, :CO2Captured], missing = []\n\n# Multiple types\nfound, missing = search_commodities([\"Electricity\", \"Heat\"], commodities)\n# found = [:Electricity], missing = [:Heat]\n\nnote: Note\nWildcard searches check against registered commodity types in MacroEnergy.jl.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.set_value-Tuple{AbstractDict, Vector{Symbol}, Any}","page":"References","title":"MacroEnergy.set_value","text":"set_value(dict::AbstractDict, keys::Vector{Symbol}, new_value)\n\nSet the value of a nested dictionary given a list of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary to modify.\nkeys::Vector{Symbol}: A list of keys representing the path to the value to \n\nbe modified.\n\nnew_value: The new value to set.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nset_value(dict, [:a, :b], 3)\nget_value(dict, [:a, :b]) # returns 3\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.struct_info-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Bool}} where T","page":"References","title":"MacroEnergy.struct_info","text":"struct_info(t::Type{T}) where T\n\nReturn a vector of tuples with the field names and types of a struct.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.timestepbefore-Tuple{Int64, Int64, Vector{StepRange{Int64, Int64}}}","page":"References","title":"MacroEnergy.timestepbefore","text":"timestepbefore(t::Int, h::Int,subperiods::Vector{StepRange{Int64,Int64})\n\nDetermines the time step that is h steps before index t in subperiod p with circular indexing.\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.write_capacity-Tuple{AbstractString, MacroEnergy.System}","page":"References","title":"MacroEnergy.write_capacity","text":"write_capacity(\n    file_path::AbstractString, \n    system::System; \n    scaling::Float64=1.0, \n    drop_cols::Vector{AbstractString}=String[], \n    commodity::Union{AbstractString,Vector{AbstractString},Nothing}=nothing, \n    asset_type::Union{AbstractString,Vector{AbstractString},Nothing}=nothing\n)\n\nWrite the optimal capacity results for all assets/edges in a system to a file.  The extension of the file determines the format of the file. Capacity, NewCapacity, and RetiredCapacity are first concatenated and then written to the file.\n\nFiltering\n\nResults can be filtered by:\n\ncommodity: Specific commodity type(s)\nasset_type: Specific asset type(s)\n\nPattern Matching\n\nTwo types of pattern matching are supported:\n\nParameter-free matching:\n\"ThermalPower\" matches any ThermalPower{...} type (i.e. no need to specify parameters inside {})\nWildcards using \"*\":\n\"ThermalPower*\" matches ThermalPower{Fuel}, ThermalPowerCCS{Fuel}, etc.\n\"CO2*\" matches CO2, CO2Captured, etc.\n\nArguments\n\nfile_path::AbstractString: The path to the file where the results will be written\nsystem::System: The system containing the assets/edges to analyze as well as the settings for the output\nscaling::Float64: The scaling factor for the results\ndrop_cols::Vector{AbstractString}: Columns to drop from the DataFrame\ncommodity::Union{AbstractString,Vector{AbstractString},Nothing}: The commodity to filter by\nasset_type::Union{AbstractString,Vector{AbstractString},Nothing}: The asset type to filter by\n\nReturns\n\nnothing: The function returns nothing, but writes the results to the file\n\nExample\n\nwrite_capacity(\"capacity.csv\", system)\n# Filter by commodity\nwrite_capacity(\"capacity.csv\", system, commodity=\"Electricity\")\n# Filter by commodity and asset type using parameter-free matching\nwrite_capacity(\"capacity.csv\", system, asset_type=\"ThermalPower\")\n# Filter by asset type using wildcard matching\nwrite_capacity(\"capacity.csv\", system, asset_type=\"ThermalPower*\")\n# Filter by commodity and asset type\nwrite_capacity(\"capacity.csv\", system, commodity=\"Electricity\", asset_type=[\"ThermalPower\", \"Battery\"])\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.write_costs-Tuple{AbstractString, MacroEnergy.System, JuMP.Model}","page":"References","title":"MacroEnergy.write_costs","text":"write_costs(\n    file_path::AbstractString, \n    system::System, \n    model::Model; \n    scaling::Float64=1.0, \n    drop_cols::Vector{<:AbstractString}=String[]\n)\n\nWrite the optimal costs for the system to a file. The extension of the file determines the format of the file.\n\nArguments\n\nfile_path::AbstractString: The path to the file where the results will be written\nsystem::System: The system containing the assets/edges to analyze as well as the settings for the output\nmodel::Model: The optimal model after the optimization\nscaling::Float64: The scaling factor for the results\ndrop_cols::Vector{<:AbstractString}: Columns to drop from the DataFrame\n\nReturns\n\nnothing: The function returns nothing, but writes the results to the file\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.write_dataframe","page":"References","title":"MacroEnergy.write_dataframe","text":"write_dataframe(\n    file_path::AbstractString, \n    df::AbstractDataFrame, \n    drop_cols::Vector{<:AbstractString}=String[]\n)\n\nWrite a DataFrame to a file in the appropriate format based on file extension. Supported formats: .csv, .csv.gz, .parquet\n\nArguments\n\nfile_path::AbstractString: Path where to save the file\ndf::AbstractDataFrame: DataFrame to write\ndrop_cols::Vector{<:AbstractString}: Columns to drop from the DataFrame\n\n\n\n\n\n","category":"function"},{"location":"references/#MacroEnergy.write_flow-Tuple{AbstractString, MacroEnergy.System}","page":"References","title":"MacroEnergy.write_flow","text":"write_flow(\n    file_path::AbstractString, \n    system::System; \n    scaling::Float64=1.0, \n    drop_cols::Vector{<:AbstractString}=String[],\n    commodity::Union{AbstractString,Vector{<:AbstractString},Nothing}=nothing,\n    asset_type::Union{AbstractString,Vector{<:AbstractString},Nothing}=nothing\n)\n\nWrite the optimal flow results for the system to a file. The extension of the file determines the format of the file.\n\nFiltering\n\nResults can be filtered by:\n\ncommodity: Specific commodity type(s)\nasset_type: Specific asset type(s)\n\nPattern Matching\n\nTwo types of pattern matching are supported:\n\nParameter-free matching:\n\"ThermalPower\" matches any ThermalPower{...} type (i.e. no need to specify parameters inside {})\nWildcards using \"*\":\n\"ThermalPower*\" matches ThermalPower{Fuel}, ThermalPowerCCS{Fuel}, etc.\n\"CO2*\" matches CO2, CO2Captured, etc.\n\nArguments\n\nfile_path::AbstractString: The path to the file where the results will be written\nsystem::System: The system containing the edges to analyze as well as the settings for the output\nscaling::Float64: The scaling factor for the results\ndrop_cols::Vector{<:AbstractString}: Columns to drop from the DataFrame\ncommodity::Union{AbstractString,Vector{<:AbstractString},Nothing}: The commodity to filter by\nasset_type::Union{AbstractString,Vector{<:AbstractString},Nothing}: The asset type to filter by\n\nReturns\n\nnothing: The function returns nothing, but writes the results to the file\n\nExample\n\nwrite_flow(\"flow.csv\", system)\n# Filter by commodity\nwrite_flow(\"flow.csv\", system, commodity=\"Electricity\")\n# Filter by commodity and asset type using parameter-free matching\nwrite_flow(\"flow.csv\", system, commodity=\"Electricity\", asset_type=\"ThermalPower\")\n# Filter by commodity and asset type using wildcard matching\nwrite_flow(\"flow.csv\", system, commodity=\"Electricity\", asset_type=\"ThermalPower*\")\n\n\n\n\n\n","category":"method"},{"location":"references/#MacroEnergy.write_results-Tuple{AbstractString, MacroEnergy.System, JuMP.Model}","page":"References","title":"MacroEnergy.write_results","text":"write_results(file_path::AbstractString, system::System, model::Model)\n\nCollects all the results as a DataFrame and then writes them to disk after the optimization is performed. \n\nArguments\n\nfile_path::AbstractString: full path of the file to export. \nsystem::System: The system object containing the case inputs.\nmodel::Model: The model being optimized.\n\nReturns\n\nExample\n\nwrite_results(case_path * \"results.csv\", system, model) # CSV\nwrite_results(case_path * \"results.csv.gz\", system, model)  # GZIP\nwrite_results(case_path * \"results.parquet\", system, model) # PARQUET\n\n\n\n\n\n","category":"method"},{"location":"create_example_case/#How-to-create-an-example-case-to-test-the-new-sectors-and-assets","page":"How to create an example case","title":"How to create an example case to test the new sectors and assets","text":"","category":"section"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"Once new sectors and assets have been created in the model, you may want to test them by creating a new example case. This section explains how to achieve this.","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"The best way to create a new example case is to include the new sectors and assets in an existing example case. They can be found in the ExampleSystems folder in the Macro repository.","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"An example case is a folder that contains all the necessary data files to run the model. The case folder should have the following structure:","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"MyCase\n│ \n├── 📁 settings\n│   └── macro_settings.yml      \nconfiguration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├── MyAsset1.json\n│   ├── MyAsset2.json\n| [...other asset types...]\n│   ├── availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"When adding a new sector, you need to make sure that: ","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"The new sector is included in the commodities.json file.\nThe new sector is included in the time_data.json file, with the corresponding HoursPerTimeStep and HoursPerSubperiod values.\nNodes corresponding to the new sector are included in the nodes.json file.\nThe demand corresponding to the new sector and for each node is included in the demand.csv file.\nA new JSON file is created with the data for the new assets.\nAvailability.csv and fuel_prices.csv files are updated with the availability and fuel prices for the new assets (if applicable).","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"warning: Warning\nMake sure that the values of the type keys in the JSON files match the names of the new sector and assets (julia abstract type and struct names respectively) created in the model. The same applies to the keys in the commodities.json and time_data.json files.","category":"page"},{"location":"assets/#Macro-Asset-Library","page":"Assets","title":"Macro Asset Library","text":"","category":"section"},{"location":"assets/","page":"Assets","title":"Assets","text":"Macro is designed to be a flexible and modular model that can adapt to various energy system representations. The model includes a library of assets that represent different technologies within the energy system.","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Each asset is defined by a combination of transformations, edges, and storage units that represent the physical and operational characteristics of a technology. These assets can be combined to create a detailed representation of the energy system, capturing the interactions between technologies and sectors. For instace, a natural gas power plant asset consists of a technology that converts natural gas into electricity while producing CO2 emissions. This asset includes:","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"A transformation vertex representing the conversion process: Natural Gas -> Electricity + CO2,\nAn incoming edge for natural gas supply,\nAn outgoing edge for electricity production, and\nA second outgoing edge for CO2 emissions.","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"All other assets in the library follow a similar structure, with specific transformations, edges, and storage units based on their respective technologies.","category":"page"},{"location":"assets/#Asset-Library","page":"Assets","title":"Asset Library","text":"","category":"section"},{"location":"assets/","page":"Assets","title":"Assets","text":"The current library includes the following assets:","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Battery","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/battery.png\" alt=\"drawing\" width=\"150\"/>","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Electrolyzer\nFuel Cell\nHydrogen Storage\nPower Line\nThermal Hydrogen Plant\nThermal Power Plant","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/natgas.png\" alt=\"drawing\" width=\"220\"/>","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Variable Renewable Energy resources (VRE)","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/solar_pv.png\" alt=\"drawing\" width=\"180\"/>","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the Macro package in Julia, please follow these steps:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Start Julia: You can start Julia by typing julia on your command line.\nOpen the Julia package manager (Pkg REPL): Once Julia has started, you can open the package manager by typing ]. Your command line should display something like (v1.x) pkg>.\n(Optional) Activate the Environment: If you want to install the Macro package in a specific environment, you can activate it by typing activate followed by the path to the environment. For instance, if your environment MyEnv is located in the directory /path/to/environment, your command should look like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(v1.x) pkg> activate /path/to/environment\n(MyEnv) pkg>","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Add Macro to the environment: you can install Macro using the Git URL (you might need to provide your GitHub username and password):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(MyEnv) pkg> add https://github.com/macroenergy/MacroEnergy.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"tip: SSH key pair\nIf an SSH key pair is set up on your GitHub account, you can use the SSH URL instead of the HTTPS URL. (MyEnv) pkg> add git@github.com:macroenergy/MacroEnergy.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia will now clone the package from the provided Git repository and install it, along with any dependencies the package might have.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Exit the Package Manager: When the installation is complete, you can exit the package manager by pressing backspace. \nImport the package: You are now ready to use the Macro package in your Julia code. Simply import it by typing:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using MacroEnergy","category":"page"},{"location":"output/#Macro-Output","page":"Output","title":"Macro Output","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Macro provides functionality to access and export optimization results. Results can be accessed in memory as DataFrames or written directly to files for further analysis.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Currently, Macro supports the following types of outputs:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Capacity results: final capacity, new capacity, retired capacity for each technology\nCosts: total, fixed, variable and total costs for the system\nFlow results: flow for each commodity through each edge\nCombined results: all results (capacity, costs, flows, non-served demand, storage level) in a single DataFrame","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"The default column names for the results in long format are:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"commodity: commodity type\ncommodity_subtype: group identifier for the variables, i.e. capacity, cost, flow\nzone: zone id\nresource_id: resource id\ncomponent_id: component id (e.g, edge id, storage id, etc.)\ntype: type of the asset\nvariable: unique identifier for the variable output (e.g, capacity, new_capacity, retired_capacity, VariableCost, FixedCost, flow)\nvalue: the value of the variable","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"warning: Output Layout\nWhen writing capacity, costs, and flow results, the user has the option to choose between two different layouts using the OutputLayout setting in the macro_settings.json file. The options are:\"OutputLayout\": \"long\" (applies to all the three outputs)\n\"OutputLayout\": \"wide\" (applies to all the three outputs)\n\"OutputLayout\": {\"Capacity\": \"wide\", \"Costs\": \"long\", \"Flow\": \"long\"} (set the layout for each output individually)Capacity ResultsLong Formatcommodity  commodity_subtype  zone    resource_id  component_id  type    variable  value\nSymbol     Symbol             Symbol  Symbol       Symbol        Symbol  Symbol    Float64Each row contains a single result specified by the variable column.Wide Formatcommodity  commodity_subtype  zone    resource_id  component_id  type    variable  capacity  new_capacity  retired_capacity\nSymbol     Symbol             Symbol  Symbol       Symbol        Symbol  Symbol    Float64   Float64       Float64Each row contains a single component_id.CostsLong Formatcommodity  commodity_subtype  zone    resource_id  component_id  type    variable  value\nSymbol     Symbol             Symbol  Symbol       Symbol        Symbol  Symbol    Float64Each row contains a single result specified by the variable column (e.g, FixedCost, VariableCost, TotalCost).Wide FormatFixedCost  VariableCost  TotalCost\nFloat64    Float64       Float64Single row for each system.Flow ResultsLong Formatcommodity  commodity_subtype  zone    resource_id  component_id  type    variable  value\nSymbol     Symbol             Symbol  Symbol       Symbol        Symbol  Symbol    Float64Each row contains a single result specified by the variable column (e.g, flow).Wide Formattime  component_id_1  component_id_2  ...\nInt64 Float64         Float64         ...\n1     100            200             ...\n2     101            201             ...\n...Each row contains a single time step for each component_id.","category":"page"},{"location":"output/#Quick-Start","page":"Output","title":"Quick Start","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"To collect and save all results at once, users can use the collect_results and write_results functions:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"# Collect all results in memory\nresults = collect_results(system, model)\n\n# Or write directly to file\nwrite_results(\"results.csv.gz\", system, model)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"note: Output Format\nMacro supports the following output formats:CSV: comma-separated values\nCSV.GZ: compressed CSV\nParquet: column-based data storeThe output format is determined by the file extension. For example, to write the results to a Parquet file instead of a CSV file, use the following line:write_results(\"results.parquet\", system, model)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"The function write_dataframe can be used to write a generic DataFrame to a file:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"write_dataframe(\"results.csv\", results) # Write the dataframe to a CSV file\nwrite_dataframe(\"results.parquet\", results) # Write the dataframe to a Parquet file\nwrite_dataframe(\"results.csv\", results, drop_cols=[\"commodity\", \"commodity_subtype\"]) # Drop the commodity and commodity_subtype columns before writing to CSV","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"As can be seen in the example above, users have the option to drop columns from the DataFrame before writing the results to a file.","category":"page"},{"location":"output/#Capacity-Results","page":"Output","title":"Capacity Results","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Results can be obtained either for the entire system or for specific assets using the get_optimal_capacity, get_optimal_new_capacity, and get_optimal_retired_capacity functions:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"# System-level results\ncapacity_results = get_optimal_capacity(system)\nnew_capacity_results = get_optimal_new_capacity(system)\nretired_capacity_results = get_optimal_retired_capacity(system)\n\n# Asset-level results\ncapacity_results = get_optimal_capacity(asset)\nnew_capacity_results = get_optimal_new_capacity(asset)\nretired_capacity_results = get_optimal_retired_capacity(asset)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"To write system-level capacity results directly to a file, users can use the write_capacity function:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"write_capacity(\"capacity.csv\", system)\n# Filter by commodity\nwrite_capacity(\"capacity.csv\", system, commodity=\"Electricity\")\n# Filter by asset type\nwrite_capacity(\"capacity.csv\", system, asset_type=\"ThermalPower\")\n# Filter by commodity and asset type\nwrite_capacity(\"capacity.csv\", system, commodity=\"Electricity\", asset_type=[\"VRE\", \"Battery\"])\n# Filter by commodity and asset type using wildcard matching\nwrite_capacity(\"capacity.csv\", system, commodity=\"Electricity\", asset_type=\"ThermalPower*\")\n# Drop columns\nwrite_capacity(\"capacity.csv\", system, drop_cols=[\"commodity\", \"commodity_subtype\", \"zone\"])","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"By default, the results are written in long format. Users can also write the results in wide format by using the OutputLayout setting in the macro_settings.json file.","category":"page"},{"location":"output/#Costs","page":"Output","title":"Costs","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"System-wide cost results can be obtained as DataFrames using the get_optimal_costs function:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"cost_results = get_optimal_costs(model)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"To write the costs results directly to a file, users can use the write_costs function:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"write_costs(\"costs.csv\", system, model)\nwrite_costs(\"costs.csv\", system, model, drop_cols=[\"commodity\", \"commodity_subtype\", \"zone\"])","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"By default, the results are written in long format. Users can also write the results in wide format by using the OutputLayout setting in the macro_settings.json file.","category":"page"},{"location":"output/#Flow-Results","page":"Output","title":"Flow Results","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"Flow results can be obtained either for the entire system or for specific assets using the get_optimal_flow function:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"# System-level results\nflow_results = get_optimal_flow(system)\n\n# Asset-level results\nflow_results = get_optimal_flow(asset)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"To write system-level flow results directly to a file, users can use the write_flow function:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"write_flow(\"flows.csv\", system)\n# Filter by commodity\nwrite_flow(\"flows.csv\", system, commodity=\"Electricity\")\n# Filter by asset type using parameter-free matching (ThermalPower{Fuel})\nwrite_flow(\"flows.csv\", system, asset_type=\"ThermalPower\")\n# Filter by asset type using wildcard matching (ThermalPower{Fuel} or ThermalPowerCCS{Fuel})\nwrite_flow(\"flows.csv\", system, asset_type=\"ThermalPower*\")\n# Drop columns\nwrite_flow(\"flows.csv\", system, drop_cols=[\"commodity\", \"commodity_subtype\", \"zone\"])","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"By default, the results are written in long format. Users can also write the results in wide format by using the OutputLayout setting in the macro_settings.json file.","category":"page"},{"location":"constraints/#Macro-Constraint-Library","page":"Constraints","title":"Macro Constraint Library","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Currently, Macro includes the following constraints:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Balance constraint\nCapacity constraint\nCO2 capture constraint\nMaximum capacity constraint\nMaximum non-served demand constraint\nMaximum non-served demand per segment constraint\nMinimum flow constraint\nMinimum storage level constraint\nMinimum up and down time constraint\nRamping limits constraint\nStorage capacity constraint\nStorage duration constraint\nStorage symmetric capacity constraint","category":"page"},{"location":"data_model/#Structure-of-the-data-model-of-Macro","page":"Data model","title":"Structure of the data model of Macro","text":"","category":"section"},{"location":"data_model/","page":"Data model","title":"Data model","text":"MyCase\n│ \n├── 📁 settings\n│   ├── macro_settings.yml      \n│   ├── solver_settings.yml     \n│   └── cpuconfig.yml           # Hardware configuration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├──battery.json\n│   ├──electrolyzers.json\n│   ├──fuel_prices.csv\n│   ├──fuelcell.json\n│   ├──h2storage.json\n│   ├──power_lines.json\n│   ├──thermal_h2.json\n│   ├──thermal_power.json\n│   ├──vre.json\n| [...other asset types...]\n│   ├──availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"sectors/#Energy-System-in-Macro","page":"Sectors","title":"Energy System in Macro","text":"","category":"section"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The Macro model is designed to represent the energy system in a detailed manner, with various sectors and technologies interacting. Each sector is characterized by a commodity, a type of energy carrier. The current model includes the following sectors:","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"Electricity\nNatural Gas\nCO2 and CO2 Capture\nHydrogen","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The energy system is modeled as a multi-plex network — a multi-layered network that connects different sectors.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The key components of this network are:","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"Nodes: Represent geographical locations or zones, each associated with a commodity type.\nTransformations: Special nodes that convert one commodity type into another, acting as bridges between sectors.\nEdges: Represent the flow of commodities between nodes and transformations.\nStorage Units: Store commodities for future use.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"In this multi-plex network, nodes of the same commodity form the network for a specific sector (e.g., electricity network, hydrogen network, etc.). The edges represent the flow of commodities between nodes, while transformations link different sectors by converting commodities from one type to another. Additionally, storage units allow for the storage of commodities for later use.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The figure below illustrates a multi-plex network representing an energy system with electricity, natural gas, and CO2 sectors, with two natural gas power plants, and a solar panel. Blue nodes represent the electricity sector, red nodes represent natural gas, and yellow nodes represent CO2. The edges depict commodity flow, and squares represent transformation points.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"(Image: Energy System)","category":"page"},{"location":"build_sectors/#How-to-build-new-sectors-in-Macro","page":"How to build a sector","title":"How to build new sectors in Macro","text":"","category":"section"},{"location":"build_sectors/#Overview","page":"How to build a sector","title":"Overview","text":"","category":"section"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The steps to build a sector in Macro are as follows:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Create new sectors/commodity types by defining new subtypes of Commodity in the MacroEnergy.jl file.\nCreate new assets. Each asset type should be a subtype of AbstractAsset and be defined in a .jl file in the src/assets folder. A make function should be defined for each asset type to create an instance of the asset.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"note: Note\nRemember to include the new files in the MacroEnergy.jl file, so that they are available when the package is loaded.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"During the creation of the assets, you will need to provide (check the following sections for an example):","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Asset structure: list of fields that define the asset in the form of transformations, edges, and storage units.\nDefault constraints for the transformations, edges, and storage units.\nStoichiometric equations/coefficients for the transformation processes.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"<ol start=\"3\">\n    <li>(Optional) Create a new JSON data file to test the new assets.</li>\n</ol>","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The following section provides an example of how to create a new sector and assets in Macro.","category":"page"},{"location":"build_sectors/#Example","page":"How to build a sector","title":"Example","text":"","category":"section"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"For example, let's create a new sector called MyNewSector with two assets: MyAsset1, and MyAsset2. ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The first asset will be a technology that converts a commodity MyNewSector, into two other commodities, Electricity and CO2, while the second asset will be a technology with a storage unit that stores the commodity MyNewSector.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"As seen in the previous section, the steps to create a new sector and assets are as follows:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Add the following line to the MacroEnergy.jl file:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"abstract type MyNewSector <: Commodity end","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"(try to add this line right after the definition of the Commodity type). ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Create a new file called MyAsset1.jl in the src/assets folder with the following content:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset1 <: AbstractAsset\n    id::AssetId\n    myasset1_transform::Transformation\n    mynewsector_edge::Edge{MyNewSector}\n    e_edge::Edge{Electricity}\n    co2_edge::Edge{CO2}\nend\n\nfunction make(::Type{MyAsset1}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # transformation\n    transform_data = process_data(data[:transforms])\n    myasset1_transform_default_constraints = [BalanceConstraint()]\n    myasset1_transform = Transformation(;\n        id = Symbol(transform_data[:id]),\n        timedata = system.time_data[Symbol(transform_data[:timedata])],\n        constraints = get(transform_data, :constraints, myasset1_transform_default_constraints),\n    )\n\n    # edges\n    mynewsector_edge_data = process_data(data[:edges][:mynewsector_edge])\n    mynewsector_edge_default_constraints = Vector{AbstractTypeConstraint}()\n    mynewsector_start_node = find_node(system.locations, Symbol(mynewsector_edge_data[:start_vertex]))\n    mynewsector_end_node = myasset1_transform\n    mynewsector_edge = Edge(\n        Symbol(String(id) * \"_\" * mynewsector_edge_data[:id]),\n        mynewsector_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        mynewsector_start_node,\n        mynewsector_end_node,\n    )\n    mynewsector_edge.constraints = get(mynewsector_edge_data, :constraints, mynewsector_edge_default_constraints)\n    mynewsector_edge.unidirectional = get(mynewsector_edge_data, :unidirectional, true)\n\n    elec_edge_data = process_data(data[:edges][:e_edge])\n    elec_start_node = myasset1_transform\n    elec_end_node = find_node(system.locations, Symbol(elec_edge_data[:end_vertex]))\n    elec_edge = EdgeWithUC(\n        Symbol(String(id) * \"_\" * elec_edge_data[:id]),\n        elec_edge_data,\n        system.time_data[:Electricity],\n        Electricity,\n        elec_start_node,\n        elec_end_node,\n    )\n    elec_edge.constraints = get(\n        elec_edge_data,\n        :constraints,\n        [\n            CapacityConstraint(),\n            RampingLimitConstraint(),\n            MinUpTimeConstraint(),\n            MinDownTimeConstraint(),\n        ],\n    )\n    elec_edge.unidirectional = get(elec_edge_data, :unidirectional, true)\n    elec_edge.startup_fuel_balance_id = :energy\n\n    co2_edge_data = process_data(data[:edges][:co2_edge])\n    co2_start_node = myasset1_transform\n    co2_end_node = find_node(system.locations, Symbol(co2_edge_data[:end_vertex]))\n    co2_edge = Edge(\n        Symbol(String(id) * \"_\" * co2_edge_data[:id]),\n        co2_edge_data,\n        system.time_data[:CO2],\n        CO2,\n        co2_start_node,\n        co2_end_node,\n    )\n    co2_edge.constraints =\n        get(co2_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    co2_edge.unidirectional = get(co2_edge_data, :unidirectional, true)\n\n    myasset1_transform.balance_data = Dict(\n        # Edit this part to include the stoichiometric equations for the transformation process \n        ),\n    )\n\n    return MyAsset1(id, myasset1_transform, mynewsector_edge, elec_edge, co2_edge)\nend","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"From the code above, you can see that the modeler needs to provide the asset structure as a Julia struct, along with the default constraints for transformations and edges (myasset1_transform_default_constraints, mynewsector_edge_default_constraints), and the stoichiometric coefficients for the transformation process being modeled (myasset1_transform.balance_data).","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"tip: Tip\nChecking out other asset files in the src/assets folder is a good place to start adding new assets. ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The creation of the second asset, MyAsset2, follows very similar steps to the creation of MyAsset1. The main difference is that MyAsset2 has a storage unit:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset2 <: AbstractAsset\n    id::AssetId\n    myasset2_storage::AbstractStorage{MyNewSector}  # <--- Storage unit\n    discharge_edge::Edge{MyNewSector}\n    charge_edge::Edge{MyNewSector}\nend\n\nfunction make(::Type{MyAsset2}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # storage\n    storage_data = process_data(data[:storage])\n    myasset2_storage_default_constraints = [\n            BalanceConstraint(),\n            StorageCapacityConstraint(),\n            StorageMaxDurationConstraint(),\n            StorageMinDurationConstraint(),\n            StorageSymmetricCapacityConstraint(),\n        ]\n    myasset2_storage = Storage(id, \n        storage_data, \n        system.time_data[Symbol(storage_data[:commodity])], \n        MyNewSector, \n        myasset2_storage_default_constraints\n    )\n\n    # edges\n    discharge_edge_data = process_data(data[:edges][:discharge_edge])\n    discharge_edge_default_constraints = [CapacityConstraint()]\n    discharge_start_node = myasset2_storage\n    discharge_end_node = find_node(system.locations, Symbol(discharge_edge_data[:end_vertex]))\n    discharge_edge = Edge(\n        Symbol(String(id) * \"_\" * discharge_edge_data[:id]),\n        discharge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        discharge_start_node,\n        discharge_end_node,\n    )\n    discharge_edge.constraints = get(discharge_edge_data, :constraints, discharge_edge_default_constraints)\n    discharge_edge.unidirectional = get(discharge_edge_data, :unidirectional, true)\n\n    charge_edge_data = process_data(data[:edges][:charge_edge])\n    charge_start_node = find_node(system.locations, Symbol(charge_edge_data[:start_vertex]))\n    charge_end_node = myasset2_storage\n    charge_edge = Edge(\n        Symbol(String(id) * \"_\" * charge_edge_data[:id]),\n        charge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        charge_start_node,\n        charge_end_node,\n    )\n    charge_edge.constraints = get(charge_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    charge_edge.unidirectional = get(charge_edge_data, :unidirectional, true)\n\n    myasset2_storage.discharge_edge = discharge_edge\n    myasset2_storage.charge_edge = charge_edge\n\n    myasset2_storage.balance_data = Dict(\n        # Edit this part to include the energy efficiency of the storage unit or any other stoiometric equations\n        ),\n    )\n\n    return MyAsset2(id, myasset2_storage, discharge_edge, charge_edge)\nend","category":"page"},{"location":"#Macro","page":"Home","title":"Macro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Macro documentation!","category":"page"},{"location":"#What-is-Macro?","page":"Home","title":"What is Macro?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MAcro-Energy System Capacity Expansion & Resource Optimization Model (MACRO) is a bottom-up, electricity-centric, macro-energy systems optimization model. It is designed to capture capacity investments, operations, and energy flows across and between multiple energy sectors and can be used to explore the impacts of different energy policies, technology costs, and other exogenous factors on the energy system. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main features of MACRO include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tailored Benders decomposition framework for optimization.\nGraph-based representation of the energy system, including nodes, storage units, edges/transmission lines, transformation nodes/conversion units.\n\"Plug and play\" flexibility for integrating various technologies and sectors (e.g., electricity, hydrogen, heat, and transport).\nTechnologically rich, granular temporal resolution for detailed analysis.\nOpen-source built using Julia and JuMP.","category":"page"},{"location":"#Software-Manual","page":"Home","title":"Software Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n    \"sectors.md\",\n    \"assets.md\",\n    \"constraints.md\",\n    \"build_sectors.md\",\n    \"create_example_case.md\",\n    \"type_hierarchy.md\",\n    \"data_model.md\",\n    \"references.md\"\n]\nDepth = 2","category":"page"},{"location":"type_hierarchy/#Macro-type-hierarchy","page":"Type hierarchy","title":"Macro type hierarchy","text":"","category":"section"},{"location":"type_hierarchy/#Commodities","page":"Type hierarchy","title":"Commodities","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"using MacroEnergy # hide\nusing AbstractTrees # hide\nusing InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = subtypes(d) # hide\nprint_tree(Commodity)","category":"page"},{"location":"type_hierarchy/#Assets","page":"Type hierarchy","title":"Assets","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(AbstractAsset)","category":"page"},{"location":"type_hierarchy/#Constraints","page":"Type hierarchy","title":"Constraints","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(MacroEnergy.AbstractTypeConstraint)","category":"page"}]
}
