var documenterSearchIndex = {"docs":
[{"location":"references.html#Package-Reference","page":"References","title":"Package Reference","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"Modules = [Macro]","category":"page"},{"location":"references.html#Macro.Edge","page":"References","title":"Macro.Edge","text":"Edge{T} <: AbstractEdge{T}\n\nA mutable struct representing an edge in a network model, parameterized by commodity type T.\n\n# Fields\n- id::Symbol: Unique identifier for the edge\n- timedata::TimeData: Time-related data for the edge\n- start_vertex::AbstractVertex: Starting vertex of the edge\n- end_vertex::AbstractVertex: Ending vertex of the edge\n- availability::Vector{Float64}: Time series of availability factors\n- can_expand::Bool: Whether edge capacity can be expanded\n- can_retire::Bool: Whether edge capacity can be retired\n- capacity::Union{AffExpr,Float64}: Total available capacity\n- capacity_size::Float64: Size factor for resource cluster\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the edge\n- distance::Float64: Physical distance of the edge\n- existing_capacity::Float64: Initial installed capacity\n- fixed_om_cost::Float64: Fixed operation and maintenance costs\n- flow::Union{JuMPVariable,Vector{Float64}}: Flow of commodity `T` through the edge at each timestep\n- has_capacity::Bool: Whether the edge has capacity variables\n- integer_decisions::Bool: Whether capacity decisions must be integer\n- investment_cost::Float64: Cost per unit of new capacity\n- loss_fraction::Float64: Fraction of flow lost during transmission\n- max_capacity::Float64: Maximum allowed capacity\n- min_capacity::Float64: Minimum required capacity\n- min_flow_fraction::Float64: Minimum flow as fraction of capacity\n- new_capacity::Union{JuMPVariable,Float64}: JuMP variable representing new capacity built\n- ramp_down_fraction::Float64: Maximum ramp-down rate as fraction of capacity\n- ramp_up_fraction::Float64: Maximum ramp-up rate as fraction of capacity\n- ret_capacity::Union{JuMPVariable,Float64}: JuMP variable representing capacity to be retired\n- unidirectional::Bool: Whether flow is restricted to one direction\n- variable_om_cost::Float64: Variable operation and maintenance costs per unit flow\n\nEdges represent connections between vertices that allow commodities to flow between them. \nThey can model physical infrastructure like pipelines, transmission lines, or logical \nconnections with associated costs, capacities, and operational constraints.\n\n\n\n\n\n","category":"type"},{"location":"references.html#Macro.EdgeWithUC","page":"References","title":"Macro.EdgeWithUC","text":"EdgeWithUC{T} <: AbstractEdge{T}\n\nA mutable struct representing an edge with unit commitment constraints in a network model, parameterized by commodity type T.\n\n# Inherited Attributes from Edge\n- id::Symbol: Unique identifier for the edge\n- timedata::TimeData: Time-related data for the edge\n- start_vertex::AbstractVertex: Starting vertex of the edge\n- end_vertex::AbstractVertex: Ending vertex of the edge\n- availability::Vector{Float64}: Time series of availability factors\n- can_expand::Bool: Whether edge capacity can be expanded\n- can_retire::Bool: Whether edge capacity can be retired\n- capacity::Union{AffExpr,Float64}: Total available capacity\n- capacity_size::Float64: Size factor for resource cluster\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the edge\n- distance::Float64: Physical distance of the edge\n- existing_capacity::Float64: Initial installed capacity\n- fixed_om_cost::Float64: Fixed operation and maintenance costs\n- flow::Union{JuMPVariable,Vector{Float64}}: Flow of commodity through the edge at each timestep\n- has_capacity::Bool: Whether the edge has capacity variables\n- integer_decisions::Bool: Whether capacity decisions must be integer\n- investment_cost::Float64: Cost per unit of new capacity\n- loss_fraction::Float64: Fraction of flow lost during transmission\n- max_capacity::Float64: Maximum allowed capacity\n- min_capacity::Float64: Minimum required capacity\n- min_flow_fraction::Float64: Minimum flow as fraction of capacity\n- new_capacity::Union{JuMPVariable,Float64}: JuMP variable representing new capacity built\n- ramp_down_fraction::Float64: Maximum ramp-down rate as fraction of capacity\n- ramp_up_fraction::Float64: Maximum ramp-up rate as fraction of capacity\n- ret_capacity::Union{JuMPVariable,Float64}: JuMP variable representing capacity to be retired\n- unidirectional::Bool: Whether flow is restricted to one direction\n- variable_om_cost::Float64: Variable operation and maintenance costs per unit flow\n\n# Fields specific to EdgeWithUC\n- min_down_time::Int64: Minimum time units that must elapse between shutting down and starting up\n- min_up_time::Int64: Minimum time units that must elapse between starting up and shutting down\n- startup_cost::Float64: Cost incurred when starting up the unit\n- startup_fuel::Float64: Amount of fuel consumed during startup\n- startup_fuel_balance_id::Symbol: Identifier for the balance constraint tracking startup fuel\n- ucommit::Union{JuMPVariable,Vector{Float64}}: Binary commitment state variables\n- ushut::Union{JuMPVariable,Vector{Float64}}: Binary shutdown decision variables\n- ustart::Union{JuMPVariable,Vector{Float64}}: Binary startup decision variables\n\nEdgeWithUC extends Edge to model units that have operational constraints related to their on/off status. It includes variables and parameters\nfor tracking unit commitment decisions and associated costs/constraints.\n\n\n\n\n\n","category":"type"},{"location":"references.html#Macro.Node","page":"References","title":"Macro.Node","text":"Node{T} <: AbstractVertex\n\nA mutable struct representing a node in a network, parameterized by commodity type T.\n\n# Inherited Attributes\n- id::Symbol: Unique identifier for the node\n- timedata::TimeData: Time-related data for the node\n- balance_data::Dict{Symbol,Dict{Symbol,Float64}}: Balance equations data\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the node\n- operation_expr::Dict: Operational JuMP expressions for the node\n\n# Fields\n- demand::Union{Vector{Float64},Dict{Int64,Float64}}: Time series of demand values\n- max_nsd::Vector{Float64}: Maximum allowed non-served demand for each segment\n- max_supply::Vector{Float64}: Maximum supply for each segment\n- non_served_demand::Union{JuMPVariable,Matrix{Float64}}: JuMP variables or matrix representing unmet demand\n- policy_budgeting_vars::Dict: Policy budgeting variables for constraints\n- policy_slack_vars::Dict: Policy slack variables for constraints\n- price::Union{Vector{Float64},Dict{Int64,Float64}}: Time series of prices\n- price_nsd::Vector{Float64}: Penalties for non-served demand by segment\n- price_supply::Vector{Float64}: Supply costs by segment\n- price_unmet_policy::Dict{DataType,Float64}: Mapping of policy types to penalty costs\n- rhs_policy::Dict{DataType,Float64}: Mapping of policy types to right-hand side values\n- supply_flow::Union{JuMPVariable,Matrix{Float64}}: JuMP variables or matrix representing supply flows\n\nNote: Base attributes are inherited from AbstractVertex via @AbstractVertexBaseAttributes macro.\n\n\n\n\n\n","category":"type"},{"location":"references.html#Macro.Storage","page":"References","title":"Macro.Storage","text":"Storage{T} <: AbstractVertex\n\nA mutable struct representing a storage vertex in a network model, parameterized by commodity type T.\n\n# Inherited Attributes\n- id::Symbol: Unique identifier for the storage\n- timedata::TimeData: Time-related data for the storage\n- balance_data::Dict{Symbol,Dict{Symbol,Float64}}: Dictionary mapping balance equation IDs to coefficients\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the storage\n- operation_expr::Dict: Dictionary storing operational JuMP expressions for the storage\n\n# Fields\n- can_expand::Bool: Whether storage capacity can be expanded\n- can_retire::Bool: Whether storage capacity can be retired\n- capacity_storage::Union{AffExpr,Float64}: Total available storage capacity\n- charge_edge::Union{Nothing,AbstractEdge}: `Edge` representing charging flow\n- charge_discharge_ratio::Float64: Ratio between charging and discharging rates\n- discharge_edge::Union{Nothing,AbstractEdge}: `Edge` representing discharging flow\n- existing_capacity_storage::Float64: Initial installed storage capacity\n- fixed_om_cost_storage::Float64: Fixed operation and maintenance costs\n- investment_cost_storage::Float64: Cost per unit of new storage capacity\n- max_capacity_storage::Float64: Maximum allowed storage capacity\n- max_duration::Float64: Maximum storage duration in hours\n- min_capacity_storage::Float64: Minimum required storage capacity\n- min_duration::Float64: Minimum storage duration in hours\n- min_outflow_fraction::Float64: Minimum discharge rate as fraction of capacity\n- min_storage_level::Float64: Minimum storage level as fraction of capacity\n- max_storage_level::Float64: Maximum storage level as fraction of capacity\n- new_capacity_storage::Union{JuMPVariable,Float64}: New storage capacity to be built\n- ret_capacity_storage::Union{JuMPVariable,Float64}: Storage capacity to be retired\n- spillage_edge::Union{Nothing,AbstractEdge}: Edge representing spillage/losses (e.g. hydro reservoirs)\n- storage_level::Union{JuMPVariable,Vector{Float64}}: Storage level at each timestep\n- storage_loss_fraction::Float64: Fraction of stored commodity lost per timestep\n\nStorage vertices represent facilities that can store commodities over time, such as batteries, \npumped hydro, or gas storage. They can charge (store) and discharge (release) commodities, \nsubject to capacity and operational constraints.\n\n\n\n\n\n","category":"type"},{"location":"references.html#Macro.Transformation","page":"References","title":"Macro.Transformation","text":"Transformation <: AbstractVertex\n\nA mutable struct representing a transformation vertex in a network model, which models a conversion process between different commodities or energy forms.\n\n# Inherited Attributes\n- id::Symbol: Unique identifier for the transformation\n- timedata::TimeData: Time-related data for the transformation\n- balance_data::Dict{Symbol,Dict{Symbol,Float64}}: Dictionary mapping stoichiometric equation IDs to coefficients\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the transformation\n- operation_expr::Dict: Dictionary storing operational JuMP expressions for the transformation\n\nTransformations are used to model conversion processes between different commodities, such as power plants \nconverting fuel to electricity or electrolyzers converting electricity to hydrogen. The `balance_data` field \ntypically contains conversion efficiencies and other relationships between input and output flows.\n\n\n\n\n\n","category":"type"},{"location":"references.html#Macro.get_value-Tuple{AbstractDict, Vector{Symbol}}","page":"References","title":"Macro.get_value","text":"get_value(dict::AbstractDict, keys::Vector{Symbol})\n\nGet the value from a dictionary based on a sequence of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary from which to retrieve the value.\nkeys::Vector{Symbol}: The sequence of keys to traverse the dictionary.\n\nReturns\n\nThe value retrieved from the dictionary based on the given keys.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value(dict, [:a, :b]) # returns 1\nget_value(dict, [:a, :c, :b]) # returns 2\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.get_value_and_keys","page":"References","title":"Macro.get_value_and_keys","text":"get_value_and_keys(dict::AbstractDict, target_key::Symbol, keys=Symbol[])\n\nRecursively searches for a target key in a dictionary and returns a list of  tuples containing the value associated with the target key and the keys leading  to it. This function is used to replace the path to a timeseries file with the actual vector of data.\n\nArguments\n\ndict::AbstractDict: The (nested) dictionary to search in.\ntarget_key::Symbol: The key to search for.\nkeys=Symbol[]: (optional) The keys leading to the current dictionary.\n\nReturns\n\nvalue_keys: A list of tuples, where each tuple contains                - the value associated with the target key               - the keys leading to it in the nested dictionary.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value_and_keys(dict, :b) # returns [(1, [:a, :b]), (2, [:a, :c, :b])]\n\nWhere the first element of the tuple is the value of the key :b and the second  element is the list of keys to reach that value.\n\n\n\n\n\n","category":"function"},{"location":"references.html#Macro.make-Tuple{Type{<:VRE}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{<:VRE}, data::AbstractDict{Symbol, Any}, system::System) -> VRE\n\nVRE is an alias for Union{SolarPV, WindTurbine}\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n- edges: Dict{Symbol, Any}\n    - edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.make-Tuple{Type{Battery}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{Battery}, data::AbstractDict{Symbol, Any}, system::System) -> Battery\n\nNecessary data fields:\n - storage: Dict{Symbol, Any}\n    - id: String\n    - commodity: String\n    - can_retire: Bool\n    - can_expand: Bool\n    - existing_capacity_storage: Float64\n    - investment_cost_storage: Float64\n    - fixed_om_cost_storage: Float64\n    - storage_loss_fraction: Float64\n    - min_duration: Float64\n    - max_duration: Float64\n    - min_storage_level: Float64\n    - min_capacity_storage: Float64\n    - max_capacity_storage: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n - edges: Dict{Symbol, Any}\n    - charge_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - efficiency: Float64\n    - discharge_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - efficiency\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.make-Tuple{Type{Electrolyzer}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{Electrolyzer}, data::AbstractDict{Symbol, Any}, system::System) -> Electrolyzer\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.make-Tuple{Type{FuelCell}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{FuelCell}, data::AbstractDict{Symbol, Any}, system::System) -> FuelCell\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.make-Tuple{Type{ThermalHydrogenCCS}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{ThermalHydrogenCCS}, data::AbstractDict{Symbol, Any}, system::System) -> ThermalHydrogenCCS\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - elec_edge: Dict{Symbol,Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - fuel_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_captured_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.make-Tuple{Type{ThermalHydrogen}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{ThermalHydrogen}, data::AbstractDict{Symbol, Any}, system::System) -> ThermalHydrogen\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - elec_edge: Dict{Symbol,Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - fuel_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_capacity: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.set_value-Tuple{AbstractDict, Vector{Symbol}, Any}","page":"References","title":"Macro.set_value","text":"set_value(dict::AbstractDict, keys::Vector{Symbol}, new_value)\n\nSet the value of a nested dictionary given a list of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary to modify.\nkeys::Vector{Symbol}: A list of keys representing the path to the value to \n\nbe modified.\n\nnew_value: The new value to set.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nset_value(dict, [:a, :b], 3)\nget_value(dict, [:a, :b]) # returns 3\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.struct_info-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Macro.struct_info","text":"struct_info(t::Type{T}) where T\n\nReturn a vector of tuples with the field names and types of a struct.\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.timestepbefore-Tuple{Int64, Int64, Vector{StepRange{Int64, Int64}}}","page":"References","title":"Macro.timestepbefore","text":"timestepbefore(t::Int, h::Int,subperiods::Vector{StepRange{Int64,Int64})\n\nDetermines the time step that is h steps before index t in subperiod p with circular indexing.\n\n\n\n\n\n","category":"method"},{"location":"references.html#Macro.@AbstractVertexBaseAttributes-Tuple{}","page":"References","title":"Macro.@AbstractVertexBaseAttributes","text":"@AbstractVertexBaseAttributes()\n\nA macro that defines the base attributes for all vertex types in the network model.\n\n# Generated Fields\n- id::Symbol: Unique identifier for the vertex\n- timedata::TimeData: Time-related data for the vertex\n- balance_data::Dict{Symbol,Dict{Symbol,Float64}}: Dictionary mapping balance equation IDs to coefficients\n- constraints::Vector{AbstractTypeConstraint}: List of constraints applied to the vertex\n- operation_expr::Dict: Dictionary storing operational JuMP expressions for the vertex\n\nThis macro is used to ensure consistent base attributes across all vertex types in the network.\n\n\n\n\n\n","category":"macro"},{"location":"build_sectors.html#How-to-build-new-sectors-in-Macro","page":"How to build a sector","title":"How to build new sectors in Macro","text":"","category":"section"},{"location":"build_sectors.html#Overview","page":"How to build a sector","title":"Overview","text":"","category":"section"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"The steps to build a sector in Macro are as follows:","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"Create new sectors/commodity types by defining new subtypes of Commodity in the Macro.jl file.\nCreate new assets. Each asset type should be a subtype of AbstractAsset and be defined in a Julia (.jl) file located in the src/assets folder. A make function should be defined for each asset type to create an instance of the asset.","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"note: Note\nRemember to include the new files in the Macro.jl file, so that they are available when the package is loaded.","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"During the creation of the assets, you will need to provide (check the following sections for an example):","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"Asset structure: list of fields that define the asset in the form of transformations, edges, and storage units.\nDefault constraints for the transformations, edges, and storage units.\nStoichiometric equations/coefficients for the transformation processes.","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"<ol start=\"4\">\n    <li>(Optional) Create a new JSON data file to test the new assets.</li>\n</ol>","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"The following section provides an example of how to create a new sector and assets in Macro.","category":"page"},{"location":"build_sectors.html#Example","page":"How to build a sector","title":"Example","text":"","category":"section"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"For example, let's create a new sector called MyNewSector with two assets: MyAsset1, and MyAsset2. ","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"The first asset will be a technology that converts a commodity MyNewSector, into two other commodities, Electricity and CO2, while the second asset will be a technology with a storage unit that stores the commodity MyNewSector.","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"As seen in the previous section, the steps to create a new sector and assets are as follows:","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"Add the following line to the Macro.jl file:","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"abstract type MyNewSector <: Commodity end","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"(try to add this line right after the definition of the Commodity type). ","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"Create a new file called MyAsset1.jl in the src/assets folder with the following content:","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset1 <: AbstractAsset\n    id::AssetId\n    myasset1_transform::Transformation\n    mynewsector_edge::Edge{MyNewSector}\n    e_edge::Edge{Electricity}\n    co2_edge::Edge{CO2}\nend\n\nfunction make(::Type{MyAsset1}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # transformation\n    transform_data = process_data(data[:transforms])\n    myasset1_transform_default_constraints = [BalanceConstraint()]\n    myasset1_transform = Transformation(;\n        id = Symbol(transform_data[:id]),\n        timedata = system.time_data[Symbol(transform_data[:timedata])],\n        constraints = get(transform_data, :constraints, myasset1_transform_default_constraints),\n    )\n\n    # edges\n    mynewsector_edge_data = process_data(data[:edges][:mynewsector_edge])\n    mynewsector_edge_default_constraints = Vector{AbstractTypeConstraint}()\n    mynewsector_start_node = find_node(system.locations, Symbol(mynewsector_edge_data[:start_vertex]))\n    mynewsector_end_node = myasset1_transform\n    mynewsector_edge = Edge(\n        Symbol(String(id) * \"_\" * mynewsector_edge_data[:id]),\n        mynewsector_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        mynewsector_start_node,\n        mynewsector_end_node,\n    )\n    mynewsector_edge.constraints = get(mynewsector_edge_data, :constraints, mynewsector_edge_default_constraints)\n    mynewsector_edge.unidirectional = get(mynewsector_edge_data, :unidirectional, true)\n\n    elec_edge_data = process_data(data[:edges][:e_edge])\n    elec_start_node = myasset1_transform\n    elec_end_node = find_node(system.locations, Symbol(elec_edge_data[:end_vertex]))\n    elec_edge = EdgeWithUC(\n        Symbol(String(id) * \"_\" * elec_edge_data[:id]),\n        elec_edge_data,\n        system.time_data[:Electricity],\n        Electricity,\n        elec_start_node,\n        elec_end_node,\n    )\n    elec_edge.constraints = get(\n        elec_edge_data,\n        :constraints,\n        [\n            CapacityConstraint(),\n            RampingLimitConstraint(),\n            MinUpTimeConstraint(),\n            MinDownTimeConstraint(),\n        ],\n    )\n    elec_edge.unidirectional = get(elec_edge_data, :unidirectional, true)\n    elec_edge.startup_fuel_balance_id = :energy\n\n    co2_edge_data = process_data(data[:edges][:co2_edge])\n    co2_start_node = myasset1_transform\n    co2_end_node = find_node(system.locations, Symbol(co2_edge_data[:end_vertex]))\n    co2_edge = Edge(\n        Symbol(String(id) * \"_\" * co2_edge_data[:id]),\n        co2_edge_data,\n        system.time_data[:CO2],\n        CO2,\n        co2_start_node,\n        co2_end_node,\n    )\n    co2_edge.constraints =\n        get(co2_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    co2_edge.unidirectional = get(co2_edge_data, :unidirectional, true)\n\n    myasset1_transform.balance_data = Dict(\n        # Edit this part to include the stoichiometric equations for the transformation process \n        ),\n    )\n\n    return MyAsset1(id, myasset1_transform, mynewsector_edge, elec_edge, co2_edge)\nend","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"From the code above, you can see that the modeler needs to provide the asset structure as a Julia struct, along with the default constraints for transformations and edges (myasset1_transform_default_constraints, mynewsector_edge_default_constraints), and the stoichiometric coefficients for the transformation process being modeled (myasset1_transform.balance_data).","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"tip: Tip\nChecking out other asset files in the src/assets folder is a good place to start adding new assets. ","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"The creation of the second asset, MyAsset2, follows very similar steps to the creation of MyAsset1. The main difference is that MyAsset2 has a storage unit:","category":"page"},{"location":"build_sectors.html","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset2 <: AbstractAsset\n    id::AssetId\n    myasset2_storage::Storage{MyNewSector}  # <--- Storage unit\n    discharge_edge::Edge{MyNewSector}\n    charge_edge::Edge{MyNewSector}\nend\n\nfunction make(::Type{MyAsset2}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # storage\n    storage_data = process_data(data[:storage])\n    myasset2_storage_default_constraints = [\n            BalanceConstraint(),\n            StorageCapacityConstraint(),\n            StorageMaxDurationConstraint(),\n            StorageMinDurationConstraint(),\n            StorageSymmetricCapacityConstraint(),\n        ]\n    myasset2_storage = Storage(id, \n        storage_data, \n        system.time_data[Symbol(storage_data[:commodity])], \n        MyNewSector, \n        myasset2_storage_default_constraints\n    )\n\n    # edges\n    discharge_edge_data = process_data(data[:edges][:discharge_edge])\n    discharge_edge_default_constraints = [CapacityConstraint()]\n    discharge_start_node = myasset2_storage\n    discharge_end_node = find_node(system.locations, Symbol(discharge_edge_data[:end_vertex]))\n    discharge_edge = Edge(\n        Symbol(String(id) * \"_\" * discharge_edge_data[:id]),\n        discharge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        discharge_start_node,\n        discharge_end_node,\n    )\n    discharge_edge.constraints = get(discharge_edge_data, :constraints, discharge_edge_default_constraints)\n    discharge_edge.unidirectional = get(discharge_edge_data, :unidirectional, true)\n\n    charge_edge_data = process_data(data[:edges][:charge_edge])\n    charge_start_node = find_node(system.locations, Symbol(charge_edge_data[:start_vertex]))\n    charge_end_node = myasset2_storage\n    charge_edge = Edge(\n        Symbol(String(id) * \"_\" * charge_edge_data[:id]),\n        charge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        charge_start_node,\n        charge_end_node,\n    )\n    charge_edge.constraints = get(charge_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    charge_edge.unidirectional = get(charge_edge_data, :unidirectional, true)\n\n    myasset2_storage.discharge_edge = discharge_edge\n    myasset2_storage.charge_edge = charge_edge\n\n    myasset2_storage.balance_data = Dict(\n        # Edit this part to include the energy efficiency of the storage unit or any other stoiometric equations\n        ),\n    )\n\n    return MyAsset2(id, myasset2_storage, discharge_edge, charge_edge)\nend","category":"page"},{"location":"constraints.html#Macro-Constraint-Library","page":"Constraints","title":"Macro Constraint Library","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"Currently, Macro includes the following constraints:","category":"page"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"Balance constraint\nCapacity constraint\nCO2 capture constraint\nMust-run constraint\nMaximum capacity constraint\nMaximum non-served demand constraint\nMaximum non-served demand per segment constraint\nMaximum storage level constraint\nMinimum flow constraint\nMinimum capacity constraint\nMinimum storage level constraint\nMinimum up and down time constraint\nRamping limits constraint\nStorage capacity constraint\nStorage discharge limit constraint\nStorage duration constraint\nStorage symmetric capacity constraint","category":"page"},{"location":"create_example_case.html#How-to-create-an-example-case-to-test-the-new-sectors-and-assets","page":"How to create an example case","title":"How to create an example case to test the new sectors and assets","text":"","category":"section"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"Once new sectors and assets have been created in the model, you may want to test them by creating a new example case. This section explains how to achieve this.","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"The best way to create a new example case is to include the new sectors and assets in an existing example case. They can be found in the ExampleSystems folder in the Macro repository.","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"An example case is a folder that contains all the necessary data files to run the model. The case folder should have the following structure:","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"MyCase\n│ \n├── 📁 settings\n│   └── macro_settings.yml      \nconfiguration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├── MyAsset1.json\n│   ├── MyAsset2.json\n| [...other asset types...]\n│   ├── availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"When adding a new sector, you need to make sure that: ","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"The new sector is included in the commodities.json file.\nThe new sector is included in the time_data.json file, with the corresponding HoursPerTimeStep and HoursPerSubperiod values.\nNodes corresponding to the new sector are included in the nodes.json file.\nThe demand corresponding to the new sector and for each node is included in the demand.csv file.\nA new JSON file is created with the data for the new assets.\nAvailability.csv and fuel_prices.csv files are updated with the availability and fuel prices for the new assets (if applicable).","category":"page"},{"location":"create_example_case.html","page":"How to create an example case","title":"How to create an example case","text":"warning: Warning\nMake sure that the values of the type keys in the JSON files match the names of the new sector and assets (julia abstract type and struct names respectively) created in the model. The same applies to the keys in the commodities.json and time_data.json files.","category":"page"},{"location":"assets.html#Macro-Asset-Library","page":"Assets","title":"Macro Asset Library","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Macro is designed to be a flexible and modular model that can adapt to various energy system representations. The model includes a library of assets that represent different technologies within the energy system.","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Each asset is defined by a combination of transformations, edges, and storage units that represent the physical and operational characteristics of a technology. These assets can be combined to create a detailed representation of the energy system, capturing the interactions between technologies and sectors. For instance, a natural gas power plant asset consists of a technology that converts natural gas into electricity while producing CO2 emissions. This asset includes:","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"A transformation vertex representing the conversion process: Natural Gas -> Electricity + CO2,\nAn incoming edge for natural gas supply,\nAn outgoing edge for electricity production, and\nA second outgoing edge for CO2 emissions.","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"All other assets in the library follow a similar structure, with specific transformations, edges, and storage units based on their respective technologies.","category":"page"},{"location":"assets.html#Asset-Library","page":"Assets","title":"Asset Library","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"The current library includes the following assets:","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Battery","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"<img src=\"assets/battery.png\" alt=\"drawing\" width=\"150\"/>","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Electrolyzer\nFuel Cell\nHydrogen Storage\nPower Line\nThermal Hydrogen Plant\nThermal Power Plant","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"<img src=\"assets/natgas.png\" alt=\"drawing\" width=\"220\"/>","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Variable Renewable Energy resources (VRE)","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"<img src=\"assets/solar_pv.png\" alt=\"drawing\" width=\"180\"/>","category":"page"},{"location":"data_model.html#Structure-of-the-data-model-of-Macro","page":"Data model","title":"Structure of the data model of Macro","text":"","category":"section"},{"location":"data_model.html","page":"Data model","title":"Data model","text":"MyCase\n│ \n├── 📁 settings\n│   ├── macro_settings.yml      \n│   ├── solver_settings.yml     \n│   └── cpuconfig.yml           # Hardware configuration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├──battery.json\n│   ├──electrolyzers.json\n│   ├──fuel_prices.csv\n│   ├──fuelcell.json\n│   ├──h2storage.json\n│   ├──power_lines.json\n│   ├──thermal_h2.json\n│   ├──thermal_power.json\n│   ├──vre.json\n| [...other asset types...]\n│   ├──availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To install the Macro package in Julia, we recommend following these steps:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Create a new folder: Before starting Julia, create a new folder for your Macro installation. You can do this in your terminal:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"mkdir MyMacroFolder\ncd MyMacroFolder","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Replace \"MyMacroFolder\" with your preferred name.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Start Julia: Start Julia in this new folder by typing julia in your terminal.\nOpen the Julia package manager (Pkg REPL): Once Julia has started, open the package manager by typing ]. Your command line should display something like (v1.x) pkg>.\nCreate and activate a new environment: Create a new environment in your current folder:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"(v1.x) pkg> activate .\n(MyMacroFolder) pkg>","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This creates and activates a new environment in the current folder. The prompt will change to show the name of your folder.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Add Macro to the environment: Now you can install Macro using the Git URL (you might need to provide your GitHub username and password):","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"(MyMacroFolder) pkg> add https://github.com/macroenergy/Macro.git#informs","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"note: Note\nYou might need to provide your GitHub username and password, you can use  Username: HongxiLuo Password: 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 (valid till Nov. 8th, 2024)","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"tip: SSH key pair\nIf an SSH key pair is set up on your GitHub account, you can use the SSH URL instead of the HTTPS URL. (MyEnv) pkg> add git@github.com:macroenergy/Macro.git","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Julia will now clone the package from the provided Git repository and install it, along with any dependencies the package might have.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Exit the Package Manager: When the installation is complete, you can exit the package manager by pressing backspace. \nImport the package: You are now ready to use the Macro package in your Julia code. Simply import it by typing:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using Macro","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = Macro","category":"page"},{"location":"index.html#Macro","page":"Home","title":"Macro","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the Macro documentation!","category":"page"},{"location":"index.html#What-is-Macro?","page":"Home","title":"What is Macro?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"MAcro-Energy System Capacity Expansion & Resource Optimization Model (MACRO) is a bottom-up, electricity-centric, macro-energy systems optimization model. It is designed to capture capacity investments, operations, and energy flows across and between multiple energy sectors and can be used to explore the impacts of different energy policies, technology costs, and other exogenous factors on the energy system. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The main features of MACRO include:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Tailored Benders decomposition framework for optimization.\nGraph-based representation of the energy system, including nodes, storage units, edges/transmission lines, transformation nodes/conversion units.\n\"Plug and play\" flexibility for integrating various technologies and sectors (e.g., electricity, hydrogen, heat, and transport).\nTechnologically rich, granular temporal resolution for detailed analysis.\nOpen-source built using Julia and JuMP.","category":"page"},{"location":"index.html#Software-Manual","page":"Home","title":"Software Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n    \"sectors.md\",\n    \"assets.md\",\n    \"constraints.md\",\n    \"build_sectors.md\",\n    \"create_example_case.md\",\n    \"type_hierarchy.md\",\n    \"data_model.md\",\n    \"references.md\"\n]\nDepth = 2","category":"page"},{"location":"sectors.html#Energy-System-in-Macro","page":"Sectors","title":"Energy System in Macro","text":"","category":"section"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"The Macro model is designed to represent the energy system in a detailed manner, with various sectors and technologies interacting. Each sector is characterized by a commodity, a type of energy carrier. The current model includes the following sectors:","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"Electricity\nNatural Gas\nCO2 and CO2 Capture\nHydrogen","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"The energy system is modeled as a multi-plex network — a multi-layered network that connects different sectors.","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"The key components of this network are:","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"Nodes: Represent geographical locations or zones, each associated with a commodity type.\nTransformations: Special nodes that convert one commodity type into another, acting as bridges between sectors.\nEdges: Represent the flow of commodities between nodes and transformations.\nStorage Units: Store commodities for future use.","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"In this multi-plex network, nodes of the same commodity form the network for a specific sector (e.g., electricity network, hydrogen network, etc.). The edges represent the flow of commodities between nodes, while transformations link different sectors by converting commodities from one type to another. Additionally, storage units allow for the storage of commodities for later use.","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"The figure below illustrates a multi-plex network representing an energy system with electricity, natural gas, and CO2 sectors, with two natural gas power plants, and a solar panel. Blue nodes represent the electricity sector, red nodes represent natural gas, and yellow nodes represent CO2. The edges depict commodity flow, and squares represent transformation points.","category":"page"},{"location":"sectors.html","page":"Sectors","title":"Sectors","text":"(Image: Energy System)","category":"page"},{"location":"type_hierarchy.html#Macro-type-hierarchy","page":"Type hierarchy","title":"Macro type hierarchy","text":"","category":"section"},{"location":"type_hierarchy.html","page":"Type hierarchy","title":"Type hierarchy","text":"CurrentModule = Macro","category":"page"},{"location":"type_hierarchy.html#Commodities","page":"Type hierarchy","title":"Commodities","text":"","category":"section"},{"location":"type_hierarchy.html","page":"Type hierarchy","title":"Type hierarchy","text":"using Macro # hide\nusing AbstractTrees # hide\nusing InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = subtypes(d) # hide\nprint_tree(Commodity)","category":"page"},{"location":"type_hierarchy.html#Assets","page":"Type hierarchy","title":"Assets","text":"","category":"section"},{"location":"type_hierarchy.html","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(AbstractAsset)","category":"page"},{"location":"type_hierarchy.html#Constraints","page":"Type hierarchy","title":"Constraints","text":"","category":"section"},{"location":"type_hierarchy.html","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(Macro.AbstractTypeConstraint)","category":"page"}]
}
