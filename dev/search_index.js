var documenterSearchIndex = {"docs":
[{"location":"references/#Package-Reference","page":"References","title":"Package Reference","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [Macro]","category":"page"},{"location":"references/#Macro.get_value-Tuple{AbstractDict, Vector{Symbol}}","page":"References","title":"Macro.get_value","text":"get_value(dict::AbstractDict, keys::Vector{Symbol})\n\nGet the value from a dictionary based on a sequence of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary from which to retrieve the value.\nkeys::Vector{Symbol}: The sequence of keys to traverse the dictionary.\n\nReturns\n\nThe value retrieved from the dictionary based on the given keys.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value(dict, [:a, :b]) # returns 1\nget_value(dict, [:a, :c, :b]) # returns 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.get_value_and_keys","page":"References","title":"Macro.get_value_and_keys","text":"get_value_and_keys(dict::AbstractDict, target_key::Symbol, keys=Symbol[])\n\nRecursively searches for a target key in a dictionary and returns a list of  tuples containing the value associated with the target key and the keys leading  to it. This function is used to replace the path to a timeseries file with the actual vector of data.\n\nArguments\n\ndict::AbstractDict: The (nested) dictionary to search in.\ntarget_key::Symbol: The key to search for.\nkeys=Symbol[]: (optional) The keys leading to the current dictionary.\n\nReturns\n\nvalue_keys: A list of tuples, where each tuple contains                - the value associated with the target key               - the keys leading to it in the nested dictionary.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nget_value_and_keys(dict, :b) # returns [(1, [:a, :b]), (2, [:a, :c, :b])]\n\nWhere the first element of the tuple is the value of the key :b and the second  element is the list of keys to reach that value.\n\n\n\n\n\n","category":"function"},{"location":"references/#Macro.make-Tuple{Type{<:VRE}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{<:VRE}, data::AbstractDict{Symbol, Any}, system::System) -> VRE\n\nVRE is an alias for Union{SolarPV, WindTurbine}\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n- edges: Dict{Symbol, Any}\n    - edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.make-Tuple{Type{Battery}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{Battery}, data::AbstractDict{Symbol, Any}, system::System) -> Battery\n\nNecessary data fields:\n - storage: Dict{Symbol, Any}\n    - id: String\n    - commodity: String\n    - can_retire: Bool\n    - can_expand: Bool\n    - existing_capacity_storage: Float64\n    - investment_cost_storage: Float64\n    - fixed_om_cost_storage: Float64\n    - storage_loss_fraction: Float64\n    - min_duration: Float64\n    - max_duration: Float64\n    - min_storage_level: Float64\n    - min_capacity_storage: Float64\n    - max_capacity_storage: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n - edges: Dict{Symbol, Any}\n    - charge_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - efficiency: Float64\n    - discharge_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - efficiency\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.make-Tuple{Type{Electrolyzer}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{Electrolyzer}, data::AbstractDict{Symbol, Any}, system::System) -> Electrolyzer\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.make-Tuple{Type{FuelCell}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{FuelCell}, data::AbstractDict{Symbol, Any}, system::System) -> FuelCell\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.make-Tuple{Type{NaturalGasHydrogen}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{NaturalGasHydrogen}, data::AbstractDict{Symbol, Any}, system::System) -> NaturalGasHydrogen\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - efficiency_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - h2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - ng_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.make-Tuple{Type{NaturalGasPower}, AbstractDict{Symbol, Any}, Macro.System}","page":"References","title":"Macro.make","text":"make(::Type{NaturalGasPower}, data::AbstractDict{Symbol, Any}, system::System) -> NaturalGasPower\n\nNecessary data fields:\n - transforms: Dict{Symbol, Any}\n    - id: String\n    - timedata: String\n    - heat_rate: Float64\n    - emission_rate: Float64\n    - constraints: Vector{AbstractTypeConstraint}\n- edges: Dict{Symbol, Any}\n    - e_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - min_up_time: Int\n        - min_down_time: Int\n        - startup_cost: Float64\n        - startup_fuel: Float64\n        - startup_fuel_balance_id: Symbol\n        - constraints: Vector{AbstractTypeConstraint}\n    - ng_edge: Dict{Symbol, Any}\n        - id: String\n        - start_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n    - co2_edge: Dict{Symbol, Any}\n        - id: String\n        - end_vertex: String\n        - unidirectional: Bool\n        - has_planning_variables: Bool\n        - can_retire: Bool\n        - can_expand: Bool\n        - constraints: Vector{AbstractTypeConstraint}\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.set_value-Tuple{AbstractDict, Vector{Symbol}, Any}","page":"References","title":"Macro.set_value","text":"set_value(dict::AbstractDict, keys::Vector{Symbol}, new_value)\n\nSet the value of a nested dictionary given a list of keys.\n\nArguments\n\ndict::AbstractDict: The dictionary to modify.\nkeys::Vector{Symbol}: A list of keys representing the path to the value to \n\nbe modified.\n\nnew_value: The new value to set.\n\nExamples\n\ndict = Dict(:a => Dict(:b => 1, :c => Dict(:b => 2)))\nset_value(dict, [:a, :b], 3)\nget_value(dict, [:a, :b]) # returns 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.struct_info-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Macro.struct_info","text":"struct_info(t::Type{T}) where T\n\nReturn a vector of tuples with the field names and types of a struct.\n\n\n\n\n\n","category":"method"},{"location":"references/#Macro.timestepbefore-Tuple{Int64, Int64, Vector{StepRange{Int64, Int64}}}","page":"References","title":"Macro.timestepbefore","text":"timestepbefore(t::Int, h::Int,subperiods::Vector{StepRange{Int64,Int64})\n\nDetermines the time step that is h steps bßefore index t in subperiod p with circular indexing.\n\n\n\n\n\n","category":"method"},{"location":"build_sectors/#How-to-build-new-sectors-in-Macro","page":"How to build a sector","title":"How to build new sectors in Macro","text":"","category":"section"},{"location":"build_sectors/#Overview","page":"How to build a sector","title":"Overview","text":"","category":"section"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The steps to build a sector in Macro are as follows:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Create new sectors/commodity types by defining new subtypes of Commodity in the Macro.jl file.\nCreate new assets. Each asset type should be a subtype of AbstractAsset and be defined in a .jl file in the src/assets folder. A make function should be defined for each asset type to create an instance of the asset.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"note: Note\nRemember to include the new files in the Macro.jl file, so that they are available when the package is loaded.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"During the creation of the assets, you will need to provide (check the following sections for an example):","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Asset structure: list of fields that define the asset in the form of transformations, edges, and storage units.\nDefault constraints for the transformations, edges, and storage units.\nStoichiometric equations/coefficients for the transformation processes.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"<ol start=\"3\">\n    <li>(Optional) Create a new JSON data file to test the new assets.</li>\n</ol>","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The following section provides an example of how to create a new sector and assets in Macro.","category":"page"},{"location":"build_sectors/#Example","page":"How to build a sector","title":"Example","text":"","category":"section"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"For example, let's create a new sector called MyNewSector with two assets: MyAsset1, and MyAsset2. ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The first asset will be a technology that converts a commodity MyNewSector, into two other commodities, Electricity and CO2, while the second asset will be a technology with a storage unit that stores the commodity MyNewSector.","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"As seen in the previous section, the steps to create a new sector and assets are as follows:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Add the following line to the Macro.jl file:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"abstract type MyNewSector <: Commodity end","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"(try to add this line right after the definition of the Commodity type). ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"Create a new file called MyAsset1.jl in the src/assets folder with the following content:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset1 <: AbstractAsset\n    id::AssetId\n    myasset1_transform::Transformation\n    mynewsector_edge::Edge{MyNewSector}\n    e_edge::Edge{Electricity}\n    co2_edge::Edge{CO2}\nend\n\nfunction make(::Type{MyAsset1}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # transformation\n    transform_data = process_data(data[:transforms])\n    myasset1_transform_default_constraints = [BalanceConstraint()]\n    myasset1_transform = Transformation(;\n        id = Symbol(transform_data[:id]),\n        timedata = system.time_data[Symbol(transform_data[:timedata])],\n        constraints = get(transform_data, :constraints, myasset1_transform_default_constraints),\n    )\n\n    # edges\n    mynewsector_edge_data = process_data(data[:edges][:mynewsector_edge])\n    mynewsector_edge_default_constraints = Vector{AbstractTypeConstraint}()\n    mynewsector_start_node = find_node(system.locations, Symbol(mynewsector_edge_data[:start_vertex]))\n    mynewsector_end_node = myasset1_transform\n    mynewsector_edge = Edge(\n        Symbol(String(id) * \"_\" * mynewsector_edge_data[:id]),\n        mynewsector_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        mynewsector_start_node,\n        mynewsector_end_node,\n    )\n    mynewsector_edge.constraints = get(mynewsector_edge_data, :constraints, mynewsector_edge_default_constraints)\n    mynewsector_edge.unidirectional = get(mynewsector_edge_data, :unidirectional, true)\n\n    elec_edge_data = process_data(data[:edges][:e_edge])\n    elec_start_node = myasset1_transform\n    elec_end_node = find_node(system.locations, Symbol(elec_edge_data[:end_vertex]))\n    elec_edge = EdgeWithUC(\n        Symbol(String(id) * \"_\" * elec_edge_data[:id]),\n        elec_edge_data,\n        system.time_data[:Electricity],\n        Electricity,\n        elec_start_node,\n        elec_end_node,\n    )\n    elec_edge.constraints = get(\n        elec_edge_data,\n        :constraints,\n        [\n            CapacityConstraint(),\n            RampingLimitConstraint(),\n            MinUpTimeConstraint(),\n            MinDownTimeConstraint(),\n        ],\n    )\n    elec_edge.unidirectional = get(elec_edge_data, :unidirectional, true)\n    elec_edge.startup_fuel_balance_id = :energy\n\n    co2_edge_data = process_data(data[:edges][:co2_edge])\n    co2_start_node = myasset1_transform\n    co2_end_node = find_node(system.locations, Symbol(co2_edge_data[:end_vertex]))\n    co2_edge = Edge(\n        Symbol(String(id) * \"_\" * co2_edge_data[:id]),\n        co2_edge_data,\n        system.time_data[:CO2],\n        CO2,\n        co2_start_node,\n        co2_end_node,\n    )\n    co2_edge.constraints =\n        get(co2_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    co2_edge.unidirectional = get(co2_edge_data, :unidirectional, true)\n\n    myasset1_transform.balance_data = Dict(\n        # Edit this part to include the stoichiometric equations for the transformation process \n        ),\n    )\n\n    return MyAsset1(id, myasset1_transform, mynewsector_edge, elec_edge, co2_edge)\nend","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"From the code above, you can see that the modeler needs to provide the asset structure as a Julia struct, along with the default constraints for transformations and edges (myasset1_transform_default_constraints, mynewsector_edge_default_constraints), and the stoichiometric coefficients for the transformation process being modeled (myasset1_transform.balance_data).","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"tip: Tip\nChecking out other asset files in the src/assets folder is a good place to start adding new assets. ","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"The creation of the second asset, MyAsset2, follows very similar steps to the creation of MyAsset1. The main difference is that MyAsset2 has a storage unit:","category":"page"},{"location":"build_sectors/","page":"How to build a sector","title":"How to build a sector","text":"struct MyAsset2 <: AbstractAsset\n    id::AssetId\n    myasset2_storage::Storage{MyNewSector}  # <--- Storage unit\n    discharge_edge::Edge{MyNewSector}\n    charge_edge::Edge{MyNewSector}\nend\n\nfunction make(::Type{MyAsset2}, data::AbstractDict{Symbol,Any}, system::System)\n\n    # asset id\n    id = AssetId(data[:id])\n\n    # storage\n    storage_data = process_data(data[:storage])\n    myasset2_storage_default_constraints = [\n            BalanceConstraint(),\n            StorageCapacityConstraint(),\n            StorageMaxDurationConstraint(),\n            StorageMinDurationConstraint(),\n            StorageSymmetricCapacityConstraint(),\n        ]\n    myasset2_storage = Storage(id, \n        storage_data, \n        system.time_data[Symbol(storage_data[:commodity])], \n        MyNewSector, \n        myasset2_storage_default_constraints\n    )\n\n    # edges\n    discharge_edge_data = process_data(data[:edges][:discharge_edge])\n    discharge_edge_default_constraints = [CapacityConstraint()]\n    discharge_start_node = myasset2_storage\n    discharge_end_node = find_node(system.locations, Symbol(discharge_edge_data[:end_vertex]))\n    discharge_edge = Edge(\n        Symbol(String(id) * \"_\" * discharge_edge_data[:id]),\n        discharge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        discharge_start_node,\n        discharge_end_node,\n    )\n    discharge_edge.constraints = get(discharge_edge_data, :constraints, discharge_edge_default_constraints)\n    discharge_edge.unidirectional = get(discharge_edge_data, :unidirectional, true)\n\n    charge_edge_data = process_data(data[:edges][:charge_edge])\n    charge_start_node = find_node(system.locations, Symbol(charge_edge_data[:start_vertex]))\n    charge_end_node = myasset2_storage\n    charge_edge = Edge(\n        Symbol(String(id) * \"_\" * charge_edge_data[:id]),\n        charge_edge_data,\n        system.time_data[:MyNewSector],\n        MyNewSector,\n        charge_start_node,\n        charge_end_node,\n    )\n    charge_edge.constraints = get(charge_edge_data, :constraints, Vector{AbstractTypeConstraint}())\n    charge_edge.unidirectional = get(charge_edge_data, :unidirectional, true)\n\n    myasset2_storage.discharge_edge = discharge_edge\n    myasset2_storage.charge_edge = charge_edge\n\n    myasset2_storage.balance_data = Dict(\n        # Edit this part to include the energy efficiency of the storage unit or any other stoiometric equations\n        ),\n    )\n\n    return MyAsset2(id, myasset2_storage, discharge_edge, charge_edge)\nend","category":"page"},{"location":"constraints/#Macro-Constraint-Library","page":"Constraints","title":"Macro Constraint Library","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Currently, Macro includes the following constraints:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Balance constraint\nCapacity constraint\nCO2 capture constraint\nMaximum capacity constraint\nMaximum non-served demand constraint\nMaximum non-served demand per segment constraint\nMinimum flow constraint\nMinimum storage level constraint\nMinimum up and down time constraint\nRamping limits constraint\nStorage capacity constraint\nStorage duration constraint\nStorage symmetric capacity constraint","category":"page"},{"location":"create_example_case/#How-to-create-an-example-case-to-test-the-new-sectors-and-assets","page":"How to create an example case","title":"How to create an example case to test the new sectors and assets","text":"","category":"section"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"Once new sectors and assets have been created in the model, you may want to test them by creating a new example case. This section explains how to achieve this.","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"The best way to create a new example case is to include the new sectors and assets in an existing example case. They can be found in the ExampleSystems folder in the Macro repository.","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"An example case is a folder that contains all the necessary data files to run the model. The case folder should have the following structure:","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"MyCase\n│ \n├── 📁 settings\n│   └── macro_settings.yml      \nconfiguration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├── MyAsset1.json\n│   ├── MyAsset2.json\n| [...other asset types...]\n│   ├── availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"When adding a new sector, you need to make sure that: ","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"The new sector is included in the commodities.json file.\nThe new sector is included in the time_data.json file, with the corresponding HoursPerTimeStep and HoursPerSubperiod values.\nNodes corresponding to the new sector are included in the nodes.json file.\nThe demand corresponding to the new sector and for each node is included in the demand.csv file.\nA new JSON file is created with the data for the new assets.\nAvailability.csv and fuel_prices.csv files are updated with the availability and fuel prices for the new assets (if applicable).","category":"page"},{"location":"create_example_case/","page":"How to create an example case","title":"How to create an example case","text":"warning: Warning\nMake sure that the values of the type keys in the JSON files match the names of the new sector and assets (julia abstract type and struct names respectively) created in the model. The same applies to the keys in the commodities.json and time_data.json files.","category":"page"},{"location":"assets/#Macro-Asset-Library","page":"Assets","title":"Macro Asset Library","text":"","category":"section"},{"location":"assets/","page":"Assets","title":"Assets","text":"Macro is designed to be a flexible and modular model that can adapt to various energy system representations. The model includes a library of assets that represent different technologies within the energy system.","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Each asset is defined by a combination of transformations, edges, and storage units that represent the physical and operational characteristics of a technology. These assets can be combined to create a detailed representation of the energy system, capturing the interactions between technologies and sectors. For instace, a natural gas power plant asset consists of a technology that converts natural gas into electricity while producing CO2 emissions. This asset includes:","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"A transformation vertex representing the conversion process: Natural Gas -> Electricity + CO2,\nAn incoming edge for natural gas supply,\nAn outgoing edge for electricity production, and\nA second outgoing edge for CO2 emissions.","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"All other assets in the library follow a similar structure, with specific transformations, edges, and storage units based on their respective technologies.","category":"page"},{"location":"assets/#Asset-Library","page":"Assets","title":"Asset Library","text":"","category":"section"},{"location":"assets/","page":"Assets","title":"Assets","text":"The current library includes the following assets:","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Battery","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/battery.png\" alt=\"drawing\" width=\"150\"/>","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Electrolyzer\nFuel Cell\nHydrogen Storage\nPower Line\nThermal Hydrogen Plant\nThermal Power Plant","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/natgas.png\" alt=\"drawing\" width=\"220\"/>","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"Variable Renewable Energy resources (VRE)","category":"page"},{"location":"assets/","page":"Assets","title":"Assets","text":"<img src=\"assets/solar_pv.png\" alt=\"drawing\" width=\"180\"/>","category":"page"},{"location":"data_model/#Structure-of-the-data-model-of-Macro","page":"Data model","title":"Structure of the data model of Macro","text":"","category":"section"},{"location":"data_model/","page":"Data model","title":"Data model","text":"MyCase\n│ \n├── 📁 settings\n│   ├── macro_settings.yml      \n│   ├── solver_settings.yml     \n│   └── cpuconfig.yml           # Hardware configuration\n│ \n├── 📁 system\n│   ├── commodities.json \n│   ├── time_data.json\n│   ├── nodes.json\n│   └── demand.csv\n│ \n├── 📁 assets\n│   ├──battery.json\n│   ├──electrolyzers.json\n│   ├──fuel_prices.csv\n│   ├──fuelcell.json\n│   ├──h2storage.json\n│   ├──power_lines.json\n│   ├──thermal_h2.json\n│   ├──thermal_power.json\n│   ├──vre.json\n| [...other asset types...]\n│   ├──availability.csv\n│   └── fuel_prices.csv\n│ \n└── system_data.json","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the Macro package in Julia, please follow these steps:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Start Julia: You can start Julia by typing julia on your command line.\nOpen the Julia package manager (Pkg REPL): Once Julia has started, you can open the package manager by typing ]. Your command line should display something like (v1.x) pkg>.\n(Optional) Activate the Environment: If you want to install the Macro package in a specific environment, you can activate it by typing activate followed by the path to the environment. For instance, if your environment MyEnv is located in the directory /path/to/environment, your command should look like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(v1.x) pkg> activate /path/to/environment\n(MyEnv) pkg>","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Add Macro to the environment: you can install Macro using the Git URL (you might need to provide your GitHub username and password):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(MyEnv) pkg> add https://github.com/macroenergy/Macro.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"tip: SSH key pair\nIf an SSH key pair is set up on your GitHub account, you can use the SSH URL instead of the HTTPS URL. (MyEnv) pkg> add git@github.com:macroenergy/Macro.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia will now clone the package from the provided Git repository and install it, along with any dependencies the package might have.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Exit the Package Manager: When the installation is complete, you can exit the package manager by pressing backspace. \nImport the package: You are now ready to use the Macro package in your Julia code. Simply import it by typing:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Macro","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Macro","category":"page"},{"location":"#Macro","page":"Home","title":"Macro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Macro documentation!","category":"page"},{"location":"#What-is-Macro?","page":"Home","title":"What is Macro?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MAcro-Energy System Capacity Expansion & Resource Optimization Model (MACRO) is a bottom-up, electricity-centric, macro-energy systems optimization model. It is designed to capture capacity investments, operations, and energy flows across and between multiple energy sectors and can be used to explore the impacts of different energy policies, technology costs, and other exogenous factors on the energy system. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main features of MACRO include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tailored Benders decomposition framework for optimization.\nGraph-based representation of the energy system, including nodes, storage units, edges/transmission lines, transformation nodes/conversion units.\n\"Plug and play\" flexibility for integrating various technologies and sectors (e.g., electricity, hydrogen, heat, and transport).\nTechnologically rich, granular temporal resolution for detailed analysis.\nOpen-source built using Julia and JuMP.","category":"page"},{"location":"#Software-Manual","page":"Home","title":"Software Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n    \"sectors.md\",\n    \"assets.md\",\n    \"constraints.md\",\n    \"build_sectors.md\",\n    \"create_example_case.md\",\n    \"type_hierarchy.md\",\n    \"data_model.md\",\n    \"references.md\"\n]\nDepth = 2","category":"page"},{"location":"sectors/#Energy-System-in-Macro","page":"Sectors","title":"Energy System in Macro","text":"","category":"section"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The Macro model is designed to represent the energy system in a detailed manner, with various sectors and technologies interacting. Each sector is characterized by a commodity, a type of energy carrier. The current model includes the following sectors:","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"Electricity\nNatural Gas\nCO2 and CO2 Capture\nHydrogen","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The energy system is modeled as a multi-plex network — a multi-layered network that connects different sectors.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The key components of this network are:","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"Nodes: Represent geographical locations or zones, each associated with a commodity type.\nTransformations: Special nodes that convert one commodity type into another, acting as bridges between sectors.\nEdges: Represent the flow of commodities between nodes and transformations.\nStorage Units: Store commodities for future use.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"In this multi-plex network, nodes of the same commodity form the network for a specific sector (e.g., electricity network, hydrogen network, etc.). The edges represent the flow of commodities between nodes, while transformations link different sectors by converting commodities from one type to another. Additionally, storage units allow for the storage of commodities for later use.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"The figure below illustrates a multi-plex network representing an energy system with electricity, natural gas, and CO2 sectors, with two natural gas power plants, and a solar panel. Blue nodes represent the electricity sector, red nodes represent natural gas, and yellow nodes represent CO2. The edges depict commodity flow, and squares represent transformation points.","category":"page"},{"location":"sectors/","page":"Sectors","title":"Sectors","text":"(Image: Energy System)","category":"page"},{"location":"type_hierarchy/#Macro-type-hierarchy","page":"Type hierarchy","title":"Macro type hierarchy","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"CurrentModule = Macro","category":"page"},{"location":"type_hierarchy/#Commodities","page":"Type hierarchy","title":"Commodities","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"using Macro # hide\nusing AbstractTrees # hide\nusing InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = subtypes(d) # hide\nprint_tree(Commodity)","category":"page"},{"location":"type_hierarchy/#Assets","page":"Type hierarchy","title":"Assets","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(AbstractAsset)","category":"page"},{"location":"type_hierarchy/#Constraints","page":"Type hierarchy","title":"Constraints","text":"","category":"section"},{"location":"type_hierarchy/","page":"Type hierarchy","title":"Type hierarchy","text":"print_tree(Macro.AbstractTypeConstraint)","category":"page"}]
}
